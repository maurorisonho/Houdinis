#!/usr/bin/env python3
"""
IPSec Quantum Vulnerability Scanner
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
Developed by: Human Logic & Coding with AI Assistance (Claude Sonnet 4.5)
License: MIT

Analyzes IPSec configurations and implementations for quantum vulnerabilities
"""

import sys
import socket
import struct
import binascii
import argparse
import time
import json
from typing import Dict, List, Optional, Tuple, Any, Union

try:
    from qiskit import QuantumCircuit, transpile
    from qiskit.providers.aer import AerSimulator
    import numpy as np

    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False

try:
    from scapy.all import IP, UDP, Raw, sr1, sr, conf
    from scapy.contrib.ikev2 import IKEv2, IKEv2_payload_SA, IKEv2_payload_KE

    SCAPY_AVAILABLE = True
except ImportError:
    SCAPY_AVAILABLE = False


class IPSecQuantumScanner:
    """IPSec Quantum Vulnerability Scanner"""

    def __init__(self) -> None:
        self.quantum_vulnerable_algorithms = {
            # Key Exchange
            "DH_GROUP_1": {
                "vulnerable": True,
                "description": "MODP 768-bit",
                "replacement": "Post-quantum KEM",
            },
            "DH_GROUP_2": {
                "vulnerable": True,
                "description": "MODP 1024-bit",
                "replacement": "Post-quantum KEM",
            },
            "DH_GROUP_5": {
                "vulnerable": True,
                "description": "MODP 1536-bit",
                "replacement": "Post-quantum KEM",
            },
            "DH_GROUP_14": {
                "vulnerable": True,
                "description": "MODP 2048-bit",
                "replacement": "Post-quantum KEM",
            },
            "DH_GROUP_15": {
                "vulnerable": True,
                "description": "MODP 3072-bit",
                "replacement": "Post-quantum KEM",
            },
            "DH_GROUP_16": {
                "vulnerable": True,
                "description": "MODP 4096-bit",
                "replacement": "Post-quantum KEM",
            },
            "DH_GROUP_19": {
                "vulnerable": True,
                "description": "ECP 256-bit",
                "replacement": "Kyber-512",
            },
            "DH_GROUP_20": {
                "vulnerable": True,
                "description": "ECP 384-bit",
                "replacement": "Kyber-768",
            },
            "DH_GROUP_21": {
                "vulnerable": True,
                "description": "ECP 521-bit",
                "replacement": "Kyber-1024",
            },
            # Authentication
            "RSA_SIGNATURES": {
                "vulnerable": True,
                "description": "RSA digital signatures",
                "replacement": "Dilithium",
            },
            "ECDSA_SHA256": {
                "vulnerable": True,
                "description": "ECDSA with SHA-256",
                "replacement": "Falcon",
            },
            "ECDSA_SHA384": {
                "vulnerable": True,
                "description": "ECDSA with SHA-384",
                "replacement": "Falcon",
            },
            "DSA_SIGNATURES": {
                "vulnerable": True,
                "description": "DSA signatures",
                "replacement": "SPHINCS+",
            },
            # Symmetric (Grover resistance)
            "AES_128": {
                "vulnerable": True,
                "description": "AES-128 (64-bit quantum security)",
                "replacement": "AES-256",
            },
            "3DES": {
                "vulnerable": True,
                "description": "3DES (56-bit security)",
                "replacement": "AES-256",
            },
            "DES": {
                "vulnerable": True,
                "description": "DES (28-bit quantum security)",
                "replacement": "AES-256",
            },
            # Hash functions
            "SHA1": {
                "vulnerable": True,
                "description": "SHA-1 (80-bit collision resistance)",
                "replacement": "SHA-3",
            },
            "MD5": {
                "vulnerable": True,
                "description": "MD5 (64-bit collision resistance)",
                "replacement": "SHA-3",
            },
        }

        self.ipsec_ports = [500, 4500]  # ISAKMP and NAT-T

    def scan_ipsec_service(
        self, target: str, port: int = 500, timeout: int = 5
    ) -> Dict:
        """Scan for IPSec/IKE service on target"""
        print(f" Scanning {target}:{port} for IPSec/IKE service...")

        result = {
            "target": target,
            "port": port,
            "service_detected": False,
            "ike_version": None,
            "error": None,
        }

        try:
            # Create IKE v1 SA_INIT request (simplified)
            if not SCAPY_AVAILABLE:
                # Fallback to basic UDP probe
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.settimeout(timeout)

                # Simple IKE probe packet
                ike_probe = b"\x00" * 8 + b"\x01\x10\x02\x00" + b"\x00" * 20
                sock.sendto(ike_probe, (target, port))

                try:
                    response, addr = sock.recvfrom(1024)
                    if len(response) > 28:  # Minimum IKE header
                        result["service_detected"] = True
                        result["ike_version"] = "IKEv1/v2 (detected via UDP probe)"
                except socket.timeout:
                    pass

                sock.close()
            else:
                # Use Scapy for more detailed analysis
                ike_packet = self._create_ike_probe()
                response = sr1(ike_packet, timeout=timeout, verbose=0)

                if response:
                    result["service_detected"] = True
                    result["ike_version"] = self._analyze_ike_response(response)
                    result["response_data"] = str(response)

        except Exception as e:
            result["error"] = str(e)

        return result

    def _create_ike_probe(self) -> Any:
        """Create IKE probe packet using Scapy"""
        if not SCAPY_AVAILABLE:
            return None

        # Create basic IKEv2 SA_INIT request
        ike_packet = IP() / UDP(dport=500) / Raw(load=b"\x00" * 28)
        return ike_packet

    def _analyze_ike_response(self, response: Union[bytes, 'IP', None]) -> str:  # type: ignore[name-defined]
        """Analyze IKE response packet"""
        if not response:
            return "Unknown"

        # Basic IKE version detection
        if hasattr(response, "load"):
            payload = bytes(response.load)
            if len(payload) >= 20:
                version = payload[17:18]
                if version == b"\x10":
                    return "IKEv1"
                elif version == b"\x20":
                    return "IKEv2"

        return "IKE (version unknown)"

    def analyze_ipsec_configuration(self, config_data: str) -> Dict:
        """Analyze IPSec configuration for quantum vulnerabilities"""
        vulnerabilities = []
        recommendations = []
        risk_score = 0

        config_lower = config_data.lower()

        # Check for quantum-vulnerable algorithms
        for alg_name, alg_info in self.quantum_vulnerable_algorithms.items():
            alg_pattern = alg_name.lower().replace("_", "[-_]?")

            if alg_pattern in config_lower or alg_name.lower() in config_lower:
                if alg_info["vulnerable"]:
                    vulnerabilities.append(
                        f"Quantum-vulnerable algorithm: {alg_name} ({alg_info['description']})"
                    )
                    recommendations.append(
                        f"Replace {alg_name} with {alg_info['replacement']}"
                    )

                    # Assign risk scores
                    if "dh_group" in alg_name.lower() and any(
                        x in alg_name.lower() for x in ["1", "2", "5"]
                    ):
                        risk_score += 5  # Very weak DH groups
                    elif "dh_group" in alg_name.lower():
                        risk_score += 3  # Stronger but still vulnerable
                    elif any(x in alg_name.lower() for x in ["rsa", "ecdsa", "dsa"]):
                        risk_score += 4  # Signature algorithms
                    elif any(x in alg_name.lower() for x in ["aes_128", "3des", "des"]):
                        risk_score += 2  # Symmetric algorithms
                    elif any(x in alg_name.lower() for x in ["sha1", "md5"]):
                        risk_score += 3  # Hash functions

        # Check for specific vulnerable patterns
        vulnerable_patterns = {
            "preshared.*key": "Pre-shared keys may be quantum-vulnerable if short",
            "certificate.*rsa": "RSA certificates are quantum-vulnerable",
            "certificate.*ecdsa": "ECDSA certificates are quantum-vulnerable",
            "pfs.*disable": "Perfect Forward Secrecy disabled - increases quantum risk",
        }

        for pattern, description in vulnerable_patterns.items():
            if pattern in config_lower:
                vulnerabilities.append(description)
                risk_score += 2

        # Determine overall risk level
        if risk_score >= 15:
            risk_level = "CRITICAL"
        elif risk_score >= 10:
            risk_level = "HIGH"
        elif risk_score >= 5:
            risk_level = "MEDIUM"
        elif risk_score > 0:
            risk_level = "LOW"
        else:
            risk_level = "MINIMAL"

        return {
            "vulnerabilities": vulnerabilities,
            "recommendations": recommendations,
            "risk_level": risk_level,
            "risk_score": risk_score,
            "quantum_vulnerable": len(vulnerabilities) > 0,
        }

    def simulate_quantum_dh_attack(self, dh_group: str, prime_size: int) -> Dict:
        """Simulate quantum attack on Diffie-Hellman key exchange"""
        if not QISKIT_AVAILABLE:
            return {
                "success": False,
                "method": "classical_estimation",
                "message": "Qiskit not available",
                "classical_time": f"2^{prime_size//2} operations",
                "quantum_advantage": "Exponential",
            }

        print(
            f"[ANALYZE] Simulating quantum attack on {dh_group} ({prime_size}-bit)..."
        )

        # Create quantum circuit for discrete logarithm
        n_qubits = min(prime_size // 32, 16)  # Scaled down for simulation
        qc = QuantumCircuit(n_qubits, n_qubits)

        # Shor's algorithm for discrete logarithm (simplified)
        # Phase 1: Initialize superposition
        for i in range(n_qubits // 2):
            qc.h(i)

        # Phase 2: Controlled modular exponentiation
        for i in range(n_qubits // 2):
            for j in range(n_qubits // 2, n_qubits):
                if (i + j) % 3 == 0:  # Simplified control
                    qc.cx(i, j)

        # Phase 3: Quantum Fourier Transform
        for i in range(n_qubits // 2):
            qc.h(i)
            for j in range(i):
                qc.cp(np.pi / (2 ** (i - j)), j, i)

        # Measure all qubits
        qc.measure_all()

        # Simulate
        simulator = AerSimulator()
        transpiled_qc = transpile(qc, simulator)
        job = simulator.run(transpiled_qc, shots=1024)
        result = job.result()
        counts = result.get_counts()

        # Calculate success metrics
        most_common = max(counts.items(), key=lambda x: x[1])
        success_probability = most_common[1] / 1024

        # Estimate real-world requirements
        logical_qubits = prime_size * 3  # Rough estimate
        physical_qubits = logical_qubits * 1000  # Error correction

        return {
            "success": True,
            "method": "quantum_simulation",
            "dh_group": dh_group,
            "prime_size": prime_size,
            "logical_qubits_required": logical_qubits,
            "physical_qubits_required": physical_qubits,
            "success_probability": success_probability,
            "quantum_time_estimate": f"{prime_size//100} hours",
            "classical_time_estimate": f"2^{prime_size//2} operations",
            "quantum_advantage": f"~2^{prime_size//2 - 10} speedup",
        }

    def generate_post_quantum_ipsec_config(self) -> Dict:
        """Generate post-quantum IPSec configuration recommendations"""
        return {
            "phase1_ike": {
                "encryption": ["AES-256-GCM", "ChaCha20-Poly1305"],
                "integrity": ["SHA-384", "SHA-512", "SHA3-256"],
                "dh_group": ["Post-quantum KEM (Kyber-1024)", "Hybrid classical+PQ"],
                "authentication": [
                    "Post-quantum signatures (Dilithium)",
                    "Certificate-based PQ auth",
                ],
            },
            "phase2_ipsec": {
                "esp_encryption": ["AES-256-GCM", "AES-256-CBC"],
                "esp_integrity": ["SHA-384", "SHA-512"],
                "pfs_group": ["Post-quantum KEM", "Extended DH groups (interim)"],
            },
            "implementation_notes": [
                "Use hybrid classical+post-quantum during transition",
                "Implement quantum key distribution (QKD) where possible",
                "Enable Perfect Forward Secrecy (PFS)",
                "Use certificate-based authentication with PQ signatures",
                "Implement post-quantum pre-shared keys",
            ],
            "migration_timeline": {
                "immediate": "Audit current configurations, plan migration",
                "short_term": "Implement stronger classical algorithms",
                "medium_term": "Deploy hybrid classical+PQ solutions",
                "long_term": "Full post-quantum migration",
            },
        }

    def scan_multiple_targets(self, targets: List[str]) -> List[Dict]:
        """Scan multiple targets for IPSec services"""
        results = []

        for target in targets:
            print(f"\n[TARGET] Scanning target: {target}")

            target_results = {
                "target": target,
                "ports_scanned": [],
                "services_found": [],
            }

            # Scan common IPSec ports
            for port in self.ipsec_ports:
                scan_result = self.scan_ipsec_service(target, port)
                target_results["ports_scanned"].append(port)

                if scan_result["service_detected"]:
                    target_results["services_found"].append(scan_result)
                    print(f" Found {scan_result['ike_version']} on port {port}")
                else:
                    print(f" No service on port {port}")

            results.append(target_results)

        return results

    def generate_comprehensive_report(
        self, targets: List[str], config_files: List[str] = None
    ) -> str:
        """Generate comprehensive IPSec quantum vulnerability report"""
        report = []
        report.append("[SECURITY] IPSec Quantum Vulnerability Assessment")
        report.append("=" * 60)
        report.append(f"[DATE] Assessment Date: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"[TARGET] Targets: {len(targets)}")
        if config_files:
            report.append(f"[FILE] Config Files: {len(config_files)}")
        report.append("")

        # Network scan results
        if targets:
            report.append(" Network Scan Results")
            report.append("-" * 40)

            scan_results = self.scan_multiple_targets(targets)

            total_services = 0
            for result in scan_results:
                target = result["target"]
                services = result["services_found"]
                total_services += len(services)

                report.append(f"[TARGET] {target}")
                if services:
                    for service in services:
                        report.append(
                            f"    Port {service['port']}: {service['ike_version']}"
                        )
                else:
                    report.append(f"    No IPSec services detected")

                if result.get("error"):
                    report.append(f"     Error: {result['error']}")

            report.append(f"\n Total IPSec services found: {total_services}")
            report.append("")

        # Configuration analysis
        if config_files:
            report.append(" Configuration Analysis")
            report.append("-" * 40)

            total_vulnerable_configs = 0
            critical_configs = []

            for config_file in config_files:
                try:
                    with open(config_file, "r") as f:
                        config_data = f.read()

                    analysis = self.analyze_ipsec_configuration(config_data)

                    if analysis["quantum_vulnerable"]:
                        total_vulnerable_configs += 1
                        if analysis["risk_level"] in ["CRITICAL", "HIGH"]:
                            critical_configs.append(config_file)

                    report.append(f"[FILE] {config_file}")
                    report.append(f"   Risk Level: {analysis['risk_level']}")
                    report.append(f"   Risk Score: {analysis['risk_score']}")
                    report.append(
                        f"   Vulnerabilities: {len(analysis['vulnerabilities'])}"
                    )

                    if analysis["vulnerabilities"]:
                        report.append(f"     Issues:")
                        for vuln in analysis["vulnerabilities"][:3]:  # Show top 3
                            report.append(f"       -  {vuln}")

                except Exception as e:
                    report.append(f"[FILE] {config_file}")
                    report.append(f"    Error reading file: {e}")

                report.append("")

        # Quantum attack simulation
        report.append("[ANALYZE] Quantum Attack Simulation")
        report.append("-" * 40)

        # Simulate attack on common DH groups
        dh_attacks = [("DH_GROUP_14", 2048), ("DH_GROUP_19", 256), ("DH_GROUP_20", 384)]

        for dh_group, key_size in dh_attacks:
            attack_result = self.simulate_quantum_dh_attack(dh_group, key_size)

            report.append(f"[TARGET] {dh_group} ({key_size}-bit)")
            if attack_result["success"]:
                report.append(f"   Method: {attack_result['method']}")
                report.append(
                    f"   Logical Qubits: {attack_result['logical_qubits_required']}"
                )
                report.append(
                    f"   Physical Qubits: {attack_result['physical_qubits_required']}"
                )
                report.append(
                    f"   Quantum Time: {attack_result['quantum_time_estimate']}"
                )
                report.append(
                    f"   Classical Time: {attack_result['classical_time_estimate']}"
                )
                report.append(
                    f"   Quantum Advantage: {attack_result['quantum_advantage']}"
                )
            else:
                report.append(f"     {attack_result['message']}")
            report.append("")

        # Post-quantum recommendations
        pq_config = self.generate_post_quantum_ipsec_config()
        report.append("  Post-Quantum IPSec Recommendations")
        report.append("-" * 50)

        report.append(" Phase 1 (IKE) Recommendations:")
        for category, options in pq_config["phase1_ike"].items():
            report.append(
                f"   {category.replace('_', ' ').title()}: {', '.join(options)}"
            )

        report.append("\n Phase 2 (IPSec) Recommendations:")
        for category, options in pq_config["phase2_ipsec"].items():
            report.append(
                f"   {category.replace('_', ' ').title()}: {', '.join(options)}"
            )

        report.append("\n Implementation Notes:")
        for note in pq_config["implementation_notes"]:
            report.append(f"    -  {note}")

        # Summary
        report.append("\n SUMMARY")
        report.append("=" * 30)
        report.append(f"Targets scanned: {len(targets)}")
        if config_files:
            report.append(f"Config files analyzed: {len(config_files)}")
            report.append(f"Vulnerable configurations: {total_vulnerable_configs}")
            report.append(f"Critical configurations: {len(critical_configs)}")

        report.append("\n  RECOMMENDATIONS:")
        report.append("    -  Audit all IPSec configurations immediately")
        report.append("    -  Plan migration to post-quantum algorithms")
        report.append("    -  Implement hybrid classical+PQ solutions")
        report.append("    -  Monitor quantum computing developments")

        return "\n".join(report)


def main():
    """Main function for IPSec quantum vulnerability scanner"""
    parser = argparse.ArgumentParser(
        description="IPSec Quantum Vulnerability Scanner",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python ipsec_quantum_vuln.py 192.168.1.1
  python ipsec_quantum_vuln.py --targets targets.txt
  python ipsec_quantum_vuln.py --config ipsec.conf --targets 10.0.0.1
  python ipsec_quantum_vuln.py host1 host2 --config config1.conf config2.conf
        """,
    )

    parser.add_argument("targets", nargs="*", help="Target IP addresses or hostnames")
    parser.add_argument(
        "--targets-file", "-t", help="File containing target addresses (one per line)"
    )
    parser.add_argument(
        "--config", "-c", action="append", help="IPSec configuration files to analyze"
    )
    parser.add_argument("--output", "-o", help="Save report to file")
    parser.add_argument(
        "--timeout", type=int, default=5, help="Scan timeout in seconds (default: 5)"
    )
    parser.add_argument(
        "--ports",
        nargs="+",
        type=int,
        default=[500, 4500],
        help="Ports to scan (default: 500 4500)",
    )

    args = parser.parse_args()

    # Collect targets
    targets = list(args.targets) if args.targets else []

    if args.targets_file:
        try:
            with open(args.targets_file, "r") as f:
                file_targets = [line.strip() for line in f if line.strip()]
                targets.extend(file_targets)
        except Exception as e:
            print(f" Error reading targets file: {e}")
            sys.exit(1)

    config_files = args.config if args.config else []

    if not targets and not config_files:
        print(" No targets or configuration files specified")
        parser.print_help()
        sys.exit(1)

    # Initialize scanner
    scanner = IPSecQuantumScanner()
    scanner.ipsec_ports = args.ports

    print(" Houdinis - IPSec Quantum Vulnerability Scanner")
    print("=" * 60)
    if targets:
        print(f"[TARGET] Targets: {', '.join(targets)}")
    if config_files:
        print(f"[FILE] Config files: {', '.join(config_files)}")
    print()

    # Generate comprehensive report
    report = scanner.generate_comprehensive_report(targets, config_files)

    # Display report
    print(report)

    # Save to file if requested
    if args.output:
        try:
            with open(args.output, "w") as f:
                f.write(report)
            print(f"\n[SAVE] Report saved to: {args.output}")
        except Exception as e:
            print(f"\n Error saving report: {e}")


if __name__ == "__main__":
    main()
