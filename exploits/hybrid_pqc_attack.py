#!/usr/bin/env python3
"""
Hybrid Classical-PQC Attack Framework
======================================

Comprehensive security analysis for hybrid cryptographic systems that combine
classical and post-quantum algorithms during the transition period.

Hybrid Cryptography:
- Combines classical (RSA, ECDH, ECDSA) with PQC (Kyber, Dilithium, etc.)
- Provides defense-in-depth during PQC transition
- Security relies on BOTH classical AND PQC components
- Common in TLS 1.3 hybrid key exchange

Attack Categories:
- Downgrade attacks (force use of weaker algorithm)
- Protocol confusion attacks
- Key exchange vulnerabilities
- Signature verification bypass
- Implementation inconsistencies
- Transition period exploits

Threat Model:
- Adversary with current classical capabilities
- Adversary with future quantum capabilities
- Protocol-level attacker (MITM, replay, etc.)

Author: Houdinis Framework
License: MIT
"""

import numpy as np
import hashlib
import time
import json
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from collections import defaultdict
from enum import Enum


class AlgorithmType(Enum):
    """Algorithm type classification"""
    CLASSICAL_KEM = "classical_kem"
    PQC_KEM = "pqc_kem"
    CLASSICAL_SIG = "classical_sig"
    PQC_SIG = "pqc_sig"


@dataclass
class HybridConfiguration:
    """Hybrid cryptographic configuration"""
    name: str
    classical_kem: str  # e.g., "ECDH-P256"
    pqc_kem: str  # e.g., "Kyber768"
    classical_sig: Optional[str]  # e.g., "ECDSA-P256"
    pqc_sig: Optional[str]  # e.g., "Dilithium3"
    combination_mode: str  # "concatenation", "xor", "kdf"
    security_level: int


# Standard hybrid configurations
HYBRID_TLS_128 = HybridConfiguration(
    name="Hybrid-TLS-128",
    classical_kem="ECDH-P256",
    pqc_kem="Kyber512",
    classical_sig="ECDSA-P256",
    pqc_sig="Dilithium2",
    combination_mode="kdf",
    security_level=1
)

HYBRID_TLS_192 = HybridConfiguration(
    name="Hybrid-TLS-192",
    classical_kem="ECDH-P384",
    pqc_kem="Kyber768",
    classical_sig="ECDSA-P384",
    pqc_sig="Dilithium3",
    combination_mode="kdf",
    security_level=3
)

HYBRID_TLS_256 = HybridConfiguration(
    name="Hybrid-TLS-256",
    classical_kem="ECDH-P521",
    pqc_kem="Kyber1024",
    classical_sig="ECDSA-P521",
    pqc_sig="Dilithium5",
    combination_mode="kdf",
    security_level=5
)


class HybridPQCAttack:
    """
    Comprehensive attack framework for hybrid classical-PQC systems.
    
    Analyzes security of hybrid schemes during the post-quantum transition period.
    """
    
    def __init__(self, config: HybridConfiguration = HYBRID_TLS_192):
        """
        Initialize hybrid attack framework.
        
        Args:
            config: Hybrid configuration to analyze
        """
        self.config = config
        self.attack_results = []
        
    def downgrade_attack(self,
                        protocol_version: str = "TLS1.3",
                        num_attempts: int = 100) -> Dict[str, Any]:
        """
        Attempt downgrade attack to force classical-only cryptography.
        
        Attacker tries to strip PQC algorithms from negotiation, forcing
        fallback to classical algorithms vulnerable to quantum attacks.
        
        Args:
            protocol_version: Protocol version being used
            num_attempts: Number of downgrade attempts
            
        Returns:
            Dictionary containing downgrade attack results
        """
        print(f"[*] Starting downgrade attack on {self.config.name}")
        print(f"[*] Protocol: {protocol_version}")
        
        successful_downgrades = 0
        downgrade_methods = {
            'cipher_suite_manipulation': 0,
            'extension_stripping': 0,
            'version_rollback': 0,
            'algorithm_removal': 0
        }
        
        for i in range(num_attempts):
            # Try different downgrade methods
            method = list(downgrade_methods.keys())[i % len(downgrade_methods)]
            downgrade_methods[method] += 1
            
            # Simulate downgrade attempt
            downgrade_result = self._attempt_downgrade(method, protocol_version)
            
            if downgrade_result['successful']:
                successful_downgrades += 1
                print(f"[!] DOWNGRADE SUCCESSFUL using {method}!")
                print(f"    Forced algorithm: {downgrade_result['forced_algorithm']}")
        
        # Assess downgrade resistance
        downgrade_rate = successful_downgrades / num_attempts
        downgrade_protected = downgrade_rate < 0.05
        
        result = {
            'attack_type': 'downgrade_attack',
            'configuration': self.config.name,
            'protocol_version': protocol_version,
            'num_attempts': num_attempts,
            'successful_downgrades': successful_downgrades,
            'downgrade_methods': downgrade_methods,
            'downgrade_rate': float(downgrade_rate),
            'downgrade_protected': downgrade_protected,
            'vulnerability_score': downgrade_rate * 10,
            'recommendation': 'Downgrade protection adequate' if downgrade_protected else 'CRITICAL: Downgrade possible!'
        }
        
        self.attack_results.append(result)
        
        print(f"[+] Downgrade attack complete:")
        print(f"    Successful downgrades: {successful_downgrades}/{num_attempts}")
        print(f"    Protection adequate: {downgrade_protected}")
        
        return result
    
    def key_exchange_confusion_attack(self,
                                     num_sessions: int = 50) -> Dict[str, Any]:
        """
        Exploit confusion between classical and PQC key exchange.
        
        Tests if implementation correctly combines keys from both algorithms
        and whether confusion can lead to security vulnerabilities.
        
        Args:
            num_sessions: Number of key exchange sessions to analyze
            
        Returns:
            Dictionary containing confusion attack results
        """
        print(f"[*] Starting key exchange confusion attack on {self.config.name}")
        print(f"[*] Testing {num_sessions} key exchange sessions...")
        
        confusion_vulnerabilities = []
        key_combination_errors = 0
        
        for i in range(num_sessions):
            # Simulate hybrid key exchange
            classical_shared = self._simulate_classical_kem()
            pqc_shared = self._simulate_pqc_kem()
            
            # Test key combination
            combined_key = self._combine_shared_secrets(
                classical_shared, pqc_shared, self.config.combination_mode
            )
            
            # Check for vulnerabilities
            vulnerability = self._check_key_confusion_vulnerability(
                classical_shared, pqc_shared, combined_key
            )
            
            if vulnerability['found']:
                confusion_vulnerabilities.append(vulnerability)
                key_combination_errors += 1
                print(f"[!] Confusion vulnerability: {vulnerability['type']}")
        
        # Analyze key independence
        key_independence = self._test_key_independence(num_sessions)
        
        confusion_secure = len(confusion_vulnerabilities) == 0 and key_independence > 0.95
        
        result = {
            'attack_type': 'key_exchange_confusion',
            'configuration': self.config.name,
            'num_sessions': num_sessions,
            'confusion_vulnerabilities': len(confusion_vulnerabilities),
            'key_combination_errors': key_combination_errors,
            'key_independence': float(key_independence),
            'combination_mode': self.config.combination_mode,
            'confusion_secure': confusion_secure,
            'vulnerability_score': len(confusion_vulnerabilities) * 2,
            'recommendation': 'Key combination appears secure' if confusion_secure else 'Key confusion vulnerability detected'
        }
        
        self.attack_results.append(result)
        
        print(f"[+] Key exchange confusion attack complete:")
        print(f"    Confusion vulnerabilities: {len(confusion_vulnerabilities)}")
        print(f"    Key independence: {key_independence:.2%}")
        
        return result
    
    def signature_verification_bypass(self,
                                     num_attempts: int = 100) -> Dict[str, Any]:
        """
        Attempt to bypass hybrid signature verification.
        
        Tests if attacker can forge signatures by exploiting verification
        logic that checks both classical and PQC signatures.
        
        Args:
            num_attempts: Number of bypass attempts
            
        Returns:
            Dictionary containing bypass attack results
        """
        print(f"[*] Starting signature verification bypass attack on {self.config.name}")
        
        successful_bypasses = 0
        bypass_strategies = {
            'classical_only': 0,
            'pqc_only': 0,
            'partial_forgery': 0,
            'timing_race': 0,
            'verification_order': 0
        }
        
        for i in range(num_attempts):
            strategy = list(bypass_strategies.keys())[i % len(bypass_strategies)]
            bypass_strategies[strategy] += 1
            
            # Attempt bypass
            bypass_result = self._attempt_signature_bypass(strategy)
            
            if bypass_result['successful']:
                successful_bypasses += 1
                print(f"[!] BYPASS SUCCESSFUL using {strategy}!")
        
        bypass_rate = successful_bypasses / num_attempts
        verification_secure = bypass_rate < 0.01
        
        result = {
            'attack_type': 'signature_verification_bypass',
            'configuration': self.config.name,
            'num_attempts': num_attempts,
            'successful_bypasses': successful_bypasses,
            'bypass_strategies': bypass_strategies,
            'bypass_rate': float(bypass_rate),
            'verification_secure': verification_secure,
            'vulnerability_score': bypass_rate * 10,
            'recommendation': 'Signature verification robust' if verification_secure else 'CRITICAL: Verification bypass possible!'
        }
        
        self.attack_results.append(result)
        
        print(f"[+] Signature verification bypass complete:")
        print(f"    Successful bypasses: {successful_bypasses}/{num_attempts}")
        
        return result
    
    def protocol_state_confusion(self,
                                num_handshakes: int = 50) -> Dict[str, Any]:
        """
        Exploit state confusion in hybrid protocol implementation.
        
        Tests if implementation maintains consistent state across classical
        and PQC operations, and if state confusion can be exploited.
        
        Args:
            num_handshakes: Number of protocol handshakes to test
            
        Returns:
            Dictionary containing state confusion results
        """
        print(f"[*] Starting protocol state confusion attack on {self.config.name}")
        
        state_inconsistencies = []
        
        for i in range(num_handshakes):
            # Simulate hybrid handshake
            handshake_states = self._simulate_hybrid_handshake()
            
            # Check for state inconsistencies
            classical_state = handshake_states['classical']
            pqc_state = handshake_states['pqc']
            
            if not self._states_consistent(classical_state, pqc_state):
                state_inconsistencies.append({
                    'handshake': i,
                    'classical_state': classical_state,
                    'pqc_state': pqc_state
                })
                print(f"[!] State inconsistency in handshake {i}")
        
        state_secure = len(state_inconsistencies) == 0
        
        result = {
            'attack_type': 'protocol_state_confusion',
            'configuration': self.config.name,
            'num_handshakes': num_handshakes,
            'state_inconsistencies': len(state_inconsistencies),
            'consistency_rate': float(1.0 - len(state_inconsistencies) / num_handshakes),
            'state_secure': state_secure,
            'vulnerability_score': len(state_inconsistencies) * 2,
            'recommendation': 'State management consistent' if state_secure else 'State confusion vulnerability'
        }
        
        self.attack_results.append(result)
        
        print(f"[+] Protocol state confusion attack complete:")
        print(f"    State inconsistencies: {len(state_inconsistencies)}/{num_handshakes}")
        
        return result
    
    def transition_period_exploit(self,
                                 deployment_phase: str = "partial",
                                 num_scenarios: int = 50) -> Dict[str, Any]:
        """
        Exploit vulnerabilities specific to the transition period.
        
        During PQC transition, mixed deployments create opportunities for
        attackers to exploit inconsistencies and compatibility issues.
        
        Args:
            deployment_phase: "early", "partial", or "late" transition
            num_scenarios: Number of deployment scenarios to test
            
        Returns:
            Dictionary containing transition exploit results
        """
        print(f"[*] Starting transition period exploit analysis")
        print(f"[*] Deployment phase: {deployment_phase}")
        
        exploitable_scenarios = []
        
        for i in range(num_scenarios):
            scenario = self._generate_transition_scenario(deployment_phase)
            
            # Test for exploitability
            if self._is_scenario_exploitable(scenario):
                exploitable_scenarios.append(scenario)
                print(f"[!] Exploitable scenario: {scenario['type']}")
        
        exploit_rate = len(exploitable_scenarios) / num_scenarios
        transition_secure = exploit_rate < 0.1
        
        result = {
            'attack_type': 'transition_period_exploit',
            'configuration': self.config.name,
            'deployment_phase': deployment_phase,
            'num_scenarios': num_scenarios,
            'exploitable_scenarios': len(exploitable_scenarios),
            'exploit_rate': float(exploit_rate),
            'transition_secure': transition_secure,
            'vulnerability_score': exploit_rate * 10,
            'recommendation': 'Transition strategy appears secure' if transition_secure else 'Transition vulnerabilities detected'
        }
        
        self.attack_results.append(result)
        
        print(f"[+] Transition period exploit analysis complete:")
        print(f"    Exploitable scenarios: {len(exploitable_scenarios)}/{num_scenarios}")
        
        return result
    
    def hybrid_kdf_weakness_analysis(self,
                                    num_samples: int = 1000) -> Dict[str, Any]:
        """
        Analyze key derivation function used to combine classical and PQC keys.
        
        Tests if the KDF properly combines inputs and provides adequate
        security when one component is weak.
        
        Args:
            num_samples: Number of KDF samples to analyze
            
        Returns:
            Dictionary containing KDF analysis results
        """
        print(f"[*] Starting hybrid KDF weakness analysis")
        print(f"[*] Combination mode: {self.config.combination_mode}")
        
        kdf_weaknesses = []
        entropy_samples = []
        
        for i in range(num_samples):
            # Generate test keys
            classical_key = np.random.bytes(32)
            pqc_key = np.random.bytes(32)
            
            # Derive hybrid key
            hybrid_key = self._combine_shared_secrets(
                classical_key, pqc_key, self.config.combination_mode
            )
            
            # Analyze entropy
            entropy = self._compute_entropy(hybrid_key)
            entropy_samples.append(entropy)
            
            # Test with weak inputs
            weak_classical = b'\x00' * 32
            weak_combined = self._combine_shared_secrets(
                weak_classical, pqc_key, self.config.combination_mode
            )
            
            # Check if PQC alone provides security
            if self._compute_entropy(weak_combined) < 200:  # < 200 bits
                kdf_weaknesses.append({
                    'scenario': 'weak_classical_key',
                    'entropy': self._compute_entropy(weak_combined)
                })
        
        mean_entropy = np.mean(entropy_samples)
        kdf_secure = len(kdf_weaknesses) < num_samples * 0.01 and mean_entropy > 240
        
        result = {
            'attack_type': 'hybrid_kdf_weakness',
            'configuration': self.config.name,
            'combination_mode': self.config.combination_mode,
            'num_samples': num_samples,
            'mean_entropy_bits': float(mean_entropy),
            'kdf_weaknesses': len(kdf_weaknesses),
            'kdf_secure': kdf_secure,
            'vulnerability_score': len(kdf_weaknesses) * 0.1 + (0 if kdf_secure else 5),
            'recommendation': 'KDF combination appears secure' if kdf_secure else 'KDF weakness detected'
        }
        
        self.attack_results.append(result)
        
        print(f"[+] Hybrid KDF analysis complete:")
        print(f"    Mean entropy: {mean_entropy:.1f} bits")
        print(f"    KDF secure: {kdf_secure}")
        
        return result
    
    def implementation_inconsistency_scan(self) -> Dict[str, Any]:
        """
        Scan for implementation inconsistencies between classical and PQC code.
        
        Tests if classical and PQC implementations have different security
        properties, error handling, or timing characteristics.
        
        Returns:
            Dictionary containing inconsistency scan results
        """
        print(f"[*] Starting implementation inconsistency scan")
        
        inconsistencies = []
        
        # Check error handling consistency
        classical_errors = self._test_error_handling('classical')
        pqc_errors = self._test_error_handling('pqc')
        
        if classical_errors != pqc_errors:
            inconsistencies.append({
                'type': 'error_handling',
                'classical': classical_errors,
                'pqc': pqc_errors
            })
        
        # Check timing consistency
        classical_timing = self._measure_operation_timing('classical', num_samples=100)
        pqc_timing = self._measure_operation_timing('pqc', num_samples=100)
        
        timing_ratio = max(classical_timing, pqc_timing) / min(classical_timing, pqc_timing)
        if timing_ratio > 5.0:
            inconsistencies.append({
                'type': 'timing_difference',
                'ratio': timing_ratio
            })
        
        # Check parameter validation consistency
        classical_validation = self._test_parameter_validation('classical')
        pqc_validation = self._test_parameter_validation('pqc')
        
        if classical_validation != pqc_validation:
            inconsistencies.append({
                'type': 'parameter_validation',
                'difference': 'validation_rules_differ'
            })
        
        implementation_consistent = len(inconsistencies) == 0
        
        result = {
            'attack_type': 'implementation_inconsistency',
            'configuration': self.config.name,
            'inconsistencies_found': len(inconsistencies),
            'inconsistency_details': inconsistencies,
            'implementation_consistent': implementation_consistent,
            'vulnerability_score': len(inconsistencies) * 1.5,
            'recommendation': 'Implementation appears consistent' if implementation_consistent else 'Implementation inconsistencies detected'
        }
        
        self.attack_results.append(result)
        
        print(f"[+] Implementation inconsistency scan complete:")
        print(f"    Inconsistencies found: {len(inconsistencies)}")
        
        return result
    
    def comprehensive_hybrid_audit(self) -> Dict[str, Any]:
        """
        Perform comprehensive security audit of hybrid configuration.
        
        Returns:
            Dictionary containing complete audit results
        """
        print(f"\n{'='*70}")
        print(f"Hybrid Classical-PQC Comprehensive Security Audit")
        print(f"Configuration: {self.config.name}")
        print(f"{'='*70}\n")
        
        audit_results = {
            'configuration': self.config.name,
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'attacks': {}
        }
        
        # Run all attacks
        audit_results['attacks']['downgrade'] = self.downgrade_attack(num_attempts=100)
        audit_results['attacks']['key_confusion'] = self.key_exchange_confusion_attack(num_sessions=50)
        audit_results['attacks']['signature_bypass'] = self.signature_verification_bypass(num_attempts=100)
        audit_results['attacks']['state_confusion'] = self.protocol_state_confusion(num_handshakes=50)
        audit_results['attacks']['transition_exploit'] = self.transition_period_exploit(
            deployment_phase="partial", num_scenarios=50
        )
        audit_results['attacks']['kdf_weakness'] = self.hybrid_kdf_weakness_analysis(num_samples=1000)
        audit_results['attacks']['implementation'] = self.implementation_inconsistency_scan()
        
        # Compute overall security score
        vulnerability_scores = [attack['vulnerability_score'] for attack in audit_results['attacks'].values()]
        average_vulnerability = np.mean(vulnerability_scores)
        max_vulnerability = np.max(vulnerability_scores)
        
        overall_secure = average_vulnerability < 3.0 and max_vulnerability < 7.0
        
        audit_results['summary'] = {
            'total_attacks': len(audit_results['attacks']),
            'average_vulnerability_score': float(average_vulnerability),
            'max_vulnerability_score': float(max_vulnerability),
            'overall_secure': overall_secure,
            'security_rating': self._compute_security_rating(average_vulnerability),
            'critical_vulnerabilities': [name for name, attack in audit_results['attacks'].items()
                                        if attack['vulnerability_score'] > 7.0]
        }
        
        print(f"\n{'='*70}")
        print(f"Audit Summary")
        print(f"{'='*70}")
        print(f"Average vulnerability: {average_vulnerability:.2f}/10")
        print(f"Max vulnerability: {max_vulnerability:.2f}/10")
        print(f"Security rating: {audit_results['summary']['security_rating']}")
        print(f"Overall secure: {overall_secure}")
        print(f"{'='*70}\n")
        
        return audit_results
    
    def export_results(self, filename: str = None) -> str:
        """Export attack results to JSON file"""
        if filename is None:
            timestamp = time.strftime('%Y%m%d_%H%M%S')
            filename = f'hybrid_pqc_attack_results_{timestamp}.json'
        
        export_data = {
            'configuration': self.config.name,
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'attack_results': self.attack_results
        }
        
        with open(filename, 'w') as f:
            json.dump(export_data, f, indent=2)
        
        print(f"[+] Results exported to: {filename}")
        return filename
    
    # Helper methods
    
    def _attempt_downgrade(self, method: str, protocol_version: str) -> Dict[str, Any]:
        """Simulate downgrade attempt"""
        # Simplified simulation - real implementation depends on protocol
        success_probability = {
            'cipher_suite_manipulation': 0.02,
            'extension_stripping': 0.03,
            'version_rollback': 0.01,
            'algorithm_removal': 0.02
        }
        
        successful = np.random.random() < success_probability.get(method, 0.01)
        
        return {
            'successful': successful,
            'forced_algorithm': self.config.classical_kem if successful else None
        }
    
    def _simulate_classical_kem(self) -> bytes:
        """Simulate classical KEM (e.g., ECDH)"""
        return hashlib.sha256(np.random.bytes(32)).digest()
    
    def _simulate_pqc_kem(self) -> bytes:
        """Simulate PQC KEM (e.g., Kyber)"""
        return hashlib.sha256(np.random.bytes(64)).digest()
    
    def _combine_shared_secrets(self, classical: bytes, pqc: bytes, mode: str) -> bytes:
        """Combine classical and PQC shared secrets"""
        if mode == "concatenation":
            return classical + pqc
        elif mode == "xor":
            return bytes(a ^ b for a, b in zip(classical, pqc))
        elif mode == "kdf":
            return hashlib.sha256(classical + pqc).digest()
        else:
            raise ValueError(f"Unknown combination mode: {mode}")
    
    def _check_key_confusion_vulnerability(self, classical: bytes, pqc: bytes,
                                          combined: bytes) -> Dict[str, Any]:
        """Check for key confusion vulnerabilities"""
        # Test if combined key depends on both inputs
        classical_only = hashlib.sha256(classical).digest()
        pqc_only = hashlib.sha256(pqc).digest()
        
        # Vulnerability if combined key equals one of the individual keys
        if combined == classical_only or combined == pqc_only:
            return {'found': True, 'type': 'single_key_dependency'}
        
        # Random chance of other confusion types
        if np.random.random() < 0.02:
            return {'found': True, 'type': 'entropy_loss'}
        
        return {'found': False, 'type': None}
    
    def _test_key_independence(self, num_tests: int) -> float:
        """Test independence of combined keys"""
        # Simplified test: check correlation
        correlations = []
        
        for _ in range(min(num_tests, 100)):
            k1 = self._combine_shared_secrets(np.random.bytes(32), np.random.bytes(32), self.config.combination_mode)
            k2 = self._combine_shared_secrets(np.random.bytes(32), np.random.bytes(32), self.config.combination_mode)
            
            # Convert to arrays and compute correlation
            arr1 = np.frombuffer(k1, dtype=np.uint8)
            arr2 = np.frombuffer(k2, dtype=np.uint8)
            
            if len(arr1) == len(arr2):
                corr = abs(np.corrcoef(arr1, arr2)[0, 1])
                if not np.isnan(corr):
                    correlations.append(corr)
        
        # Independence score: lower correlation is better
        return 1.0 - np.mean(correlations) if correlations else 1.0
    
    def _attempt_signature_bypass(self, strategy: str) -> Dict[str, Any]:
        """Attempt to bypass signature verification"""
        success_probability = {
            'classical_only': 0.005,
            'pqc_only': 0.005,
            'partial_forgery': 0.01,
            'timing_race': 0.02,
            'verification_order': 0.015
        }
        
        successful = np.random.random() < success_probability.get(strategy, 0.005)
        
        return {'successful': successful}
    
    def _simulate_hybrid_handshake(self) -> Dict[str, str]:
        """Simulate hybrid protocol handshake"""
        # Simplified simulation
        base_state = np.random.choice(['INIT', 'KEY_EXCHANGE', 'AUTH', 'FINISHED'])
        
        # Introduce occasional inconsistencies
        if np.random.random() < 0.05:
            classical_state = base_state
            pqc_state = np.random.choice(['INIT', 'KEY_EXCHANGE', 'AUTH', 'FINISHED'])
        else:
            classical_state = pqc_state = base_state
        
        return {
            'classical': classical_state,
            'pqc': pqc_state
        }
    
    def _states_consistent(self, classical_state: str, pqc_state: str) -> bool:
        """Check if protocol states are consistent"""
        return classical_state == pqc_state
    
    def _generate_transition_scenario(self, phase: str) -> Dict[str, Any]:
        """Generate transition period scenario"""
        scenarios = {
            'early': ['no_pqc_support', 'fallback_to_classical', 'hybrid_optional'],
            'partial': ['mixed_deployment', 'version_mismatch', 'partial_upgrade'],
            'late': ['legacy_classical', 'deprecation_period', 'forced_hybrid']
        }
        
        scenario_type = np.random.choice(scenarios.get(phase, scenarios['partial']))
        
        return {
            'type': scenario_type,
            'phase': phase,
            'client_supports_pqc': np.random.random() > 0.3,
            'server_supports_pqc': np.random.random() > 0.2
        }
    
    def _is_scenario_exploitable(self, scenario: Dict[str, Any]) -> bool:
        """Check if transition scenario is exploitable"""
        # Exploitable if only one side supports PQC (asymmetric deployment)
        client_pqc = scenario['client_supports_pqc']
        server_pqc = scenario['server_supports_pqc']
        
        return client_pqc != server_pqc or np.random.random() < 0.1
    
    def _compute_entropy(self, data: bytes) -> float:
        """Compute Shannon entropy in bits"""
        if len(data) == 0:
            return 0.0
        
        byte_counts = defaultdict(int)
        for byte in data:
            byte_counts[byte] += 1
        
        entropy = 0.0
        for count in byte_counts.values():
            p = count / len(data)
            entropy -= p * np.log2(p)
        
        return entropy * len(data)  # Total entropy in bits
    
    def _test_error_handling(self, component: str) -> Dict[str, Any]:
        """Test error handling consistency"""
        # Simplified simulation
        return {
            'null_input': 'exception',
            'invalid_length': 'exception',
            'out_of_range': 'exception' if np.random.random() > 0.1 else 'silent_fail'
        }
    
    def _measure_operation_timing(self, component: str, num_samples: int) -> float:
        """Measure operation timing"""
        timings = []
        for _ in range(num_samples):
            start = time.perf_counter_ns()
            # Simulate operation
            time.sleep(np.random.uniform(1e-6, 5e-6) * (2 if component == 'pqc' else 1))
            elapsed = time.perf_counter_ns() - start
            timings.append(elapsed)
        
        return np.mean(timings)
    
    def _test_parameter_validation(self, component: str) -> Dict[str, bool]:
        """Test parameter validation consistency"""
        return {
            'checks_bounds': True,
            'validates_format': True,
            'rejects_invalid': np.random.random() > 0.05
        }
    
    def _compute_security_rating(self, avg_vulnerability: float) -> str:
        """Compute overall security rating"""
        if avg_vulnerability < 2.0:
            return "EXCELLENT"
        elif avg_vulnerability < 4.0:
            return "GOOD"
        elif avg_vulnerability < 6.0:
            return "MODERATE"
        elif avg_vulnerability < 8.0:
            return "POOR"
        else:
            return "CRITICAL"


def main():
    """Main demonstration of hybrid PQC attack framework"""
    print("Hybrid Classical-PQC Attack Framework")
    print("=" * 70)
    
    # Test all three hybrid configurations
    for config in [HYBRID_TLS_128, HYBRID_TLS_192, HYBRID_TLS_256]:
        print(f"\nTesting {config.name}...")
        
        # Initialize attack framework
        attacker = HybridPQCAttack(config)
        
        # Run comprehensive audit
        results = attacker.comprehensive_hybrid_audit()
        
        # Export results
        attacker.export_results(f'hybrid_{config.name.lower().replace("-", "_")}_audit.json')
        
        print("\n" + "=" * 70)


if __name__ == '__main__':
    main()
