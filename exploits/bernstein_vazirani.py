"""
Houdinis Framework - Bernstein-Vazirani Algorithm Implementation
Data de Criação: 15 de dezembro de 2025
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
Developed by: Human Logic & Coding with AI Assistance (Claude Sonnet 4.5)
License: MIT

Bernstein-Vazirani algorithm for finding hidden bitstrings.
Demonstrates quantum parallelism and oracle problem solving.
"""

import sys
from pathlib import Path
import numpy as np
from typing import Dict, Any, Optional, List

sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
    from qiskit_aer import Aer
    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False
    print("[!] Qiskit not available. Using classical simulation.")

from quantum.simulator import QuantumSimulator


class BernsteinVaziraniAlgorithm:
    """
    Bernstein-Vazirani algorithm implementation.
    
    Problem: Given a black-box function f(x) = s·x (mod 2) where s is a secret
    bitstring, find s.
    
    Classical complexity: O(n) queries (need n queries to determine n-bit string)
    Quantum complexity: O(1) query - finds entire string in one query!
    
    Cryptanalysis applications:
    - Hidden number problem (basis for discrete log algorithms)
    - Linear cryptanalysis
    - Key recovery attacks
    """
    
    def __init__(self, num_qubits: int = 4, backend: Optional[str] = None) -> None:
        """
        Initialize Bernstein-Vazirani algorithm.
        
        Args:
            num_qubits: Number of qubits (length of secret string)
            backend: Quantum backend to use
        """
        self.num_qubits = num_qubits
        self.backend_name = backend or "aer_simulator"
        self.simulator = QuantumSimulator(num_qubits=num_qubits + 1)
    
    def create_oracle(self, secret_string: str) -> QuantumCircuit:
        """
        Create oracle for Bernstein-Vazirani problem.
        
        The oracle implements f(x) = s·x (mod 2) where s is the secret string.
        
        Args:
            secret_string: Secret bitstring to hide in oracle
            
        Returns:
            Quantum circuit implementing the oracle
        """
        n = len(secret_string)
        qr = QuantumRegister(n + 1, 'q')
        oracle = QuantumCircuit(qr, name=f'BV Oracle (s={secret_string})')
        
        # Apply CNOT from each qubit i to output qubit if s[i] = 1
        for i, bit in enumerate(reversed(secret_string)):
            if bit == '1':
                oracle.cx(i, n)
        
        return oracle
    
    def run_algorithm(self, secret_string: str) -> Dict[str, Any]:
        """
        Run Bernstein-Vazirani algorithm to find hidden bitstring.
        
        Args:
            secret_string: Secret bitstring to find
            
        Returns:
            Result dictionary with found string and metadata
        """
        if not QISKIT_AVAILABLE:
            return self._run_classical_simulation(secret_string)
        
        n = len(secret_string)
        
        # Create quantum circuit
        qr = QuantumRegister(n + 1, 'q')
        cr = ClassicalRegister(n, 'c')
        qc = QuantumCircuit(qr, cr)
        
        # Step 1: Initialize
        # Input qubits to |0...0>, output qubit to |1>
        qc.x(n)
        
        # Step 2: Apply Hadamard to all qubits
        qc.h(range(n + 1))
        qc.barrier()
        
        # Step 3: Apply oracle
        oracle = self.create_oracle(secret_string)
        qc = qc.compose(oracle)
        qc.barrier()
        
        # Step 4: Apply Hadamard to input qubits
        qc.h(range(n))
        qc.barrier()
        
        # Step 5: Measure input qubits
        qc.measure(range(n), range(n))
        
        # Execute on quantum backend
        backend = Aer.get_backend(self.backend_name)
        transpiled = transpile(qc, backend)
        job = backend.run(transpiled, shots=1024)
        result = job.result()
        counts = result.get_counts()
        
        # Get most frequent measurement (should be the secret string)
        found_string = max(counts, key=counts.get)
        confidence = counts[found_string] / 1024
        
        # Check if correct
        correct = (found_string == secret_string)
        
        print(f"[*] Bernstein-Vazirani Algorithm Results:")
        print(f"    Secret string: {secret_string}")
        print(f"    Found string:  {found_string}")
        print(f"    Correct: {'' if correct else ''}")
        print(f"    Confidence: {confidence:.2%}")
        print(f"    Queries used: 1 (quantum) vs {n} (classical)")
        print(f"    Speedup: {n}x")
        
        return {
            "success": True,
            "num_qubits": n,
            "secret_string": secret_string,
            "found_string": found_string,
            "correct": correct,
            "confidence": confidence,
            "measurements": counts,
            "quantum_queries": 1,
            "classical_queries": n,
            "speedup": n,
            "circuit_depth": transpiled.depth(),
            "circuit": qc,
        }
    
    def _run_classical_simulation(self, secret_string: str) -> Dict[str, Any]:
        """
        Classical simulation fallback.
        
        Args:
            secret_string: Secret string to find
            
        Returns:
            Simulation results
        """
        print(f"[*] Running classical simulation of Bernstein-Vazirani")
        print(f"    Secret string: {secret_string}")
        
        n = len(secret_string)
        
        # Classical algorithm: query oracle n times
        # Query with x = 100...0, 010...0, ..., 000...1
        found_bits = []
        for i in range(n):
            # Simulate query with i-th bit set
            x = '0' * i + '1' + '0' * (n - i - 1)
            # Oracle returns s[i]
            found_bits.append(secret_string[n - i - 1])
        
        found_string = ''.join(found_bits)
        correct = (found_string == secret_string)
        
        print(f"[*] Classical algorithm:")
        print(f"    Queries needed: {n}")
        print(f"    Found string: {found_string}")
        print(f"    Correct: {'' if correct else ''}")
        
        return {
            "success": True,
            "num_qubits": n,
            "secret_string": secret_string,
            "found_string": found_string,
            "correct": correct,
            "confidence": 1.0,
            "quantum_queries": 1,
            "classical_queries": n,
            "speedup": n,
            "method": "classical_simulation",
        }
    
    def attack_linear_function(self, key_bits: str) -> Dict[str, Any]:
        """
        Simulate attack on linear function using BV algorithm.
        
        In cryptanalysis, finding linear relationships in ciphers
        can lead to key recovery. BV algorithm can efficiently
        find such relationships.
        
        Args:
            key_bits: Simulated key bits (linear mask)
            
        Returns:
            Attack results
        """
        print("\n" + "=" * 70)
        print("LINEAR CRYPTANALYSIS ATTACK SIMULATION")
        print("=" * 70)
        print(f"[*] Target: Linear function with key mask: {key_bits}")
        print(f"[*] Attack: Use BV algorithm to recover mask in 1 query")
        
        result = self.run_algorithm(key_bits)
        
        if result["correct"]:
            print(f"\n[+]  Key mask recovered successfully!")
            print(f"[+] Attack succeeded with {result['quantum_queries']} quantum query")
            print(f"[+] Classical attack would need {result['classical_queries']} queries")
            print(f"[+] Quantum speedup: {result['speedup']}x")
        else:
            print(f"\n[-]  Attack failed")
        
        return result


def test_bernstein_vazirani() -> None:
    """Test Bernstein-Vazirani algorithm with various secret strings."""
    print("=" * 70)
    print("BERNSTEIN-VAZIRANI ALGORITHM - TESTING")
    print("=" * 70)
    
    test_cases = [
        "101",      # 3 bits
        "1010",     # 4 bits
        "11001",    # 5 bits
        "101010",   # 6 bits
        "1111",     # All ones
        "0000",     # All zeros
    ]
    
    success_count = 0
    
    for secret in test_cases:
        print(f"\n{'=' * 70}")
        print(f"Test: Secret string = {secret}")
        print("=" * 70)
        
        n = len(secret)
        bv = BernsteinVaziraniAlgorithm(num_qubits=n)
        result = bv.run_algorithm(secret)
        
        if result["correct"]:
            success_count += 1
            print(f"[+]  Test passed")
        else:
            print(f"[-]  Test failed")
    
    print(f"\n{'=' * 70}")
    print(f"[+] Tests passed: {success_count}/{len(test_cases)}")
    print("=" * 70)


def demonstrate_cryptanalysis() -> None:
    """Demonstrate cryptanalysis applications."""
    print("\n" + "=" * 70)
    print("CRYPTANALYSIS APPLICATIONS")
    print("=" * 70)
    
    # Simulate linear cryptanalysis attack
    print("\n[*] Scenario: Linear approximation of block cipher")
    print("[*] Goal: Find linear mask that approximates cipher behavior")
    
    key_mask = "10110101"  # 8-bit linear mask
    bv = BernsteinVaziraniAlgorithm(num_qubits=len(key_mask))
    result = bv.attack_linear_function(key_mask)
    
    print("\n" + "=" * 70)
    print("APPLICATIONS IN CRYPTOGRAPHY")
    print("=" * 70)
    print("""
The Bernstein-Vazirani algorithm has applications in:

1. LINEAR CRYPTANALYSIS
   - Find linear approximations of ciphers
   - Recover key bits from linear masks
   - Classical: O(n) queries
   - Quantum: O(1) query - linear speedup

2. HIDDEN NUMBER PROBLEM
   - Basis for discrete logarithm algorithms
   - Related to Diffie-Hellman cryptanalysis
   - Foundation for more complex quantum attacks

3. SIMON'S ALGORITHM (Generalization)
   - Finds hidden periods (exponential speedup)
   - Can break certain symmetric encryption schemes
   - Related to post-quantum cryptography

4. FUNCTION LEARNING
   - Learn boolean functions efficiently
   - Test cryptographic primitives
   - Verify implementation correctness

5. QUANTUM SPEEDUP DEMONSTRATION
   - Clear example of quantum advantage
   - Parallelism through superposition
   - Demonstrates oracle problem solving
    """)
    
    print("=" * 70)


def compare_with_classical() -> None:
    """Compare quantum vs classical query complexity."""
    print("\n" + "=" * 70)
    print("QUANTUM VS CLASSICAL COMPARISON")
    print("=" * 70)
    
    print("\n{:<15} {:<20} {:<20} {:<15}".format(
        "String Length", "Classical Queries", "Quantum Queries", "Speedup"
    ))
    print("-" * 70)
    
    for n in [4, 8, 16, 32, 64, 128, 256]:
        classical = n
        quantum = 1
        speedup = classical / quantum
        
        print("{:<15} {:<20} {:<20} {:<15}".format(
            f"{n} bits", f"{classical}", f"{quantum}", f"{speedup}x"
        ))
    
    print("\n[*] Quantum algorithm always uses 1 query!")
    print("[*] Classical algorithm needs n queries for n-bit string")
    print("[*] Linear speedup, but significant for large strings")
    
    print("\n" + "=" * 70)


if __name__ == "__main__":
    test_bernstein_vazirani()
    demonstrate_cryptanalysis()
    compare_with_classical()
