"""
Houdinis Framework - Lattice-based Cryptography Attack Tools
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
Desenvolvido: Lógica e Codificação por Humano e AI Assistida (Claude Sonnet 4.5)
License: MIT

Quantum and classical attacks on lattice-based cryptographic schemes.
Targets NTRU, LWE (Learning With Errors), and other lattice problems.

Use Cases:
- Attacking NTRU encryption
- Breaking LWE-based schemes (Kyber, Dilithium)
- Closest Vector Problem (CVP) solving
- Shortest Vector Problem (SVP) approximation
"""

import sys
from pathlib import Path
import numpy as np
from typing import List, Dict, Any, Optional, Tuple

sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    from qiskit import QuantumCircuit
    from qiskit_aer import Aer

    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False

from quantum.backend import QuantumBackendBase
from quantum.simulator import QuantumSimulator


class LatticeAttack:
    """
    Quantum-enhanced attacks on lattice-based cryptography.

    Lattice problems are believed to be quantum-resistant, but quantum
    algorithms can still provide speedups for certain attacks.
    """

    def __init__(self, dimension: int = 4, backend=None) -> None:
        """
        Initialize lattice attack.

        Args:
            dimension: Lattice dimension
            backend: Quantum backend (optional)
        """
        self.dimension = dimension
        self.backend = backend
        self.simulator = QuantumSimulator(num_qubits=dimension)

    def attack_ntru(
        self, h: np.ndarray, q: int, ciphertext: np.ndarray
    ) -> Dict[str, Any]:
        """
        Attack NTRU encryption scheme.

        NTRU is based on polynomial rings over lattices. This attack
        attempts to recover the private key or plaintext.

        Args:
            h: Public key (polynomial)
            q: Modulus
            ciphertext: Encrypted message

        Returns:
            Attack results
        """
        print(f"[*] Attacking NTRU encryption")
        print(f"[*] Dimension: {len(h)}, Modulus: {q}")

        # Convert to lattice problem
        # NTRU security relies on SVP (Shortest Vector Problem)
        lattice_basis = self._ntru_to_lattice(h, q)

        # Find short vector (approximation)
        short_vector = self._find_short_vector(lattice_basis)

        # Attempt to recover private key
        recovered_key = self._recover_ntru_key(short_vector, h, q)

        # Try to decrypt
        if recovered_key is not None:
            plaintext = self._ntru_decrypt(ciphertext, recovered_key, q)
            success = True
        else:
            plaintext = None
            success = False

        result = {
            "public_key": h.tolist(),
            "ciphertext": ciphertext.tolist(),
            "recovered_key": (
                recovered_key.tolist() if recovered_key is not None else None
            ),
            "plaintext": plaintext.tolist() if plaintext is not None else None,
            "success": success,
            "lattice_dimension": len(h),
            "modulus": q,
        }

        if success:
            print(f"[+] NTRU attack successful!")
            print(f"    Recovered key: {recovered_key[:5]}...")
        else:
            print(f"[-] NTRU attack failed - lattice too hard")

        return result

    def attack_lwe(
        self, A: np.ndarray, b: np.ndarray, q: int, error_bound: int
    ) -> Dict[str, Any]:
        """
        Attack LWE (Learning With Errors) problem.

        LWE is the foundation for many post-quantum schemes like
        Kyber (encryption) and Dilithium (signatures).

        Args:
            A: Public matrix
            b: Target vector (b = As + e mod q)
            q: Modulus
            error_bound: Bound on error terms

        Returns:
            Attack results with recovered secret
        """
        print(f"[*] Attacking LWE problem")
        print(f"[*] Matrix size: {A.shape}, Modulus: {q}")

        # Convert LWE to lattice problem
        lattice_basis = self._lwe_to_lattice(A, b, q, error_bound)

        # Use quantum-enhanced BKZ reduction
        if QISKIT_AVAILABLE and self.backend:
            reduced_basis = self._quantum_bkz_reduction(lattice_basis)
        else:
            reduced_basis = self._classical_bkz_reduction(lattice_basis)

        # Extract secret from reduced basis
        secret = self._extract_lwe_secret(reduced_basis, A, b, q)

        # Verify solution
        if secret is not None:
            reconstruction = (A @ secret) % q
            error = (b - reconstruction) % q
            error_norm = np.linalg.norm(error)
            success = error_norm <= error_bound * np.sqrt(len(b))
        else:
            error_norm = None
            success = False

        result = {
            "matrix_shape": A.shape,
            "secret": secret.tolist() if secret is not None else None,
            "error_norm": float(error_norm) if error_norm is not None else None,
            "error_bound": error_bound,
            "success": success,
            "modulus": q,
        }

        if success:
            print(f"[+] LWE secret recovered!")
            print(f"    Secret: {secret[:5]}...")
            print(f"    Error norm: {error_norm:.2f}")
        else:
            print(f"[-] LWE attack failed")

        return result

    def solve_cvp(
        self, lattice_basis: np.ndarray, target: np.ndarray
    ) -> Dict[str, Any]:
        """
        Solve Closest Vector Problem (CVP).

        CVP is used in many cryptographic attacks and is NP-hard.
        Quantum algorithms provide moderate speedups.

        Args:
            lattice_basis: Basis vectors of the lattice
            target: Target vector

        Returns:
            Closest lattice vector
        """
        print(f"[*] Solving CVP (Closest Vector Problem)")
        print(f"[*] Lattice dimension: {lattice_basis.shape}")

        # Babai's nearest plane algorithm (classical)
        closest = self._babai_cvp(lattice_basis, target)

        # Compute distance
        distance = np.linalg.norm(closest - target)

        # Try quantum optimization for better solution
        if QISKIT_AVAILABLE:
            quantum_closest = self._quantum_cvp_optimization(
                lattice_basis, target, closest
            )
            quantum_distance = np.linalg.norm(quantum_closest - target)

            if quantum_distance < distance:
                closest = quantum_closest
                distance = quantum_distance
                method = "quantum-enhanced"
            else:
                method = "classical"
        else:
            method = "classical"

        result = {
            "lattice_basis": lattice_basis.tolist(),
            "target": target.tolist(),
            "closest_vector": closest.tolist(),
            "distance": float(distance),
            "method": method,
            "dimension": lattice_basis.shape[0],
        }

        print(f"[+] CVP solved using {method} method")
        print(f"    Distance to target: {distance:.4f}")

        return result

    def _ntru_to_lattice(self, h: np.ndarray, q: int) -> np.ndarray:
        """Convert NTRU problem to lattice basis."""
        n = len(h)
        basis = np.zeros((2 * n, 2 * n))

        # First n rows: rotations of h with q
        for i in range(n):
            for j in range(n):
                basis[i][j] = h[(j - i) % n]
            basis[i][n + i] = q

        # Last n rows: identity
        for i in range(n):
            basis[n + i][i] = 1

        return basis

    def _lwe_to_lattice(
        self, A: np.ndarray, b: np.ndarray, q: int, error_bound: int
    ) -> np.ndarray:
        """Convert LWE problem to lattice basis."""
        m, n = A.shape

        # Create lattice basis
        basis = np.zeros((m + n + 1, m + n + 1))

        # Upper-left: qI
        basis[:m, :m] = q * np.eye(m)

        # Upper-right: A^T
        basis[:m, m : m + n] = A.T

        # Lower-right: I
        basis[m : m + n, m : m + n] = np.eye(n)

        # Last row: b and error scaling
        basis[m + n, :m] = b
        basis[m + n, m + n] = error_bound

        return basis

    def _find_short_vector(self, basis: np.ndarray) -> np.ndarray:
        """
        Find short vector in lattice (SVP approximation).
        Uses LLL algorithm.
        """
        # Simplified LLL reduction
        reduced = self._lll_reduction(basis)

        # Return shortest vector
        norms = [np.linalg.norm(row) for row in reduced]
        shortest_idx = np.argmin(norms)

        return reduced[shortest_idx]

    def _lll_reduction(self, basis: np.ndarray) -> np.ndarray:
        """
        LLL (Lenstra-Lenstra-Lovász) lattice basis reduction.
        Simplified implementation.
        """
        n = len(basis)
        basis = basis.copy().astype(float)

        # Gram-Schmidt orthogonalization
        def gram_schmidt(B: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
            B_star = np.zeros_like(B)
            mu = np.zeros((n, n))

            for i in range(n):
                B_star[i] = B[i].copy()
                for j in range(i):
                    mu[i][j] = np.dot(B[i], B_star[j]) / np.dot(B_star[j], B_star[j])
                    B_star[i] -= mu[i][j] * B_star[j]

            return B_star, mu

        # LLL reduction
        k = 1
        delta = 0.75

        while k < n:
            B_star, mu = gram_schmidt(basis)

            # Size reduction
            for j in range(k - 1, -1, -1):
                if abs(mu[k][j]) > 0.5:
                    basis[k] -= round(mu[k][j]) * basis[j]

            # Lovász condition
            B_star, mu = gram_schmidt(basis)
            if np.dot(B_star[k], B_star[k]) >= (delta - mu[k][k - 1] ** 2) * np.dot(
                B_star[k - 1], B_star[k - 1]
            ):
                k += 1
            else:
                # Swap
                basis[[k, k - 1]] = basis[[k - 1, k]]
                k = max(k - 1, 1)

        return basis

    def _classical_bkz_reduction(self, basis: np.ndarray) -> np.ndarray:
        """BKZ (Block Korkine-Zolotarev) reduction - simplified."""
        # Use LLL as simplified BKZ
        return self._lll_reduction(basis)

    def _quantum_bkz_reduction(self, basis: np.ndarray) -> np.ndarray:
        """Quantum-enhanced BKZ reduction."""
        # For now, use classical BKZ
        # Future: implement quantum sampling for better block reduction
        return self._classical_bkz_reduction(basis)

    def _recover_ntru_key(
        self, short_vector: np.ndarray, h: np.ndarray, q: int
    ) -> Optional[np.ndarray]:
        """Recover NTRU private key from short vector."""
        n = len(h)

        # Extract f and g from short vector
        f = short_vector[:n] % q
        g = short_vector[n : 2 * n] % q

        # Verify if valid NTRU key
        if np.linalg.norm(f) < np.sqrt(n) and np.linalg.norm(g) < np.sqrt(n):
            return f

        return None

    def _ntru_decrypt(
        self, ciphertext: np.ndarray, private_key: np.ndarray, q: int
    ) -> np.ndarray:
        """Decrypt NTRU ciphertext."""
        # Simplified NTRU decryption
        n = len(private_key)

        # Multiply ciphertext by private key
        a = np.convolve(ciphertext, private_key)[:n] % q

        # Center and reduce
        plaintext = (a + q // 2) % q - q // 2

        return plaintext % 2  # Binary plaintext

    def _extract_lwe_secret(
        self, reduced_basis: np.ndarray, A: np.ndarray, b: np.ndarray, q: int
    ) -> Optional[np.ndarray]:
        """Extract LWE secret from reduced lattice basis."""
        m, n = A.shape

        # Look for short vector in reduced basis
        for vec in reduced_basis:
            # Try to extract secret from this vector
            candidate = vec[m : m + n] % q

            # Verify
            reconstruction = (A @ candidate) % q
            error = np.linalg.norm((b - reconstruction) % q)

            if error < np.sqrt(m):
                return candidate.astype(int)

        return None

    def _babai_cvp(self, basis: np.ndarray, target: np.ndarray) -> np.ndarray:
        """Babai's nearest plane algorithm for CVP."""
        # Gram-Schmidt orthogonalization
        n = len(basis)
        basis_star = np.zeros_like(basis)

        for i in range(n):
            basis_star[i] = basis[i].copy()
            for j in range(i):
                mu = np.dot(basis[i], basis_star[j]) / np.dot(
                    basis_star[j], basis_star[j]
                )
                basis_star[i] -= mu * basis_star[j]

        # Find coefficients
        coeffs = np.zeros(n)
        t = target.copy()

        for i in range(n - 1, -1, -1):
            coeffs[i] = round(
                np.dot(t, basis_star[i]) / np.dot(basis_star[i], basis_star[i])
            )
            t -= coeffs[i] * basis[i]

        # Construct closest vector
        closest = sum(coeffs[i] * basis[i] for i in range(n))

        return closest

    def _quantum_cvp_optimization(
        self, basis: np.ndarray, target: np.ndarray, initial_solution: np.ndarray
    ) -> np.ndarray:
        """Use quantum optimization to improve CVP solution."""
        # Placeholder for quantum optimization
        # Could use QAOA or quantum annealing
        return initial_solution


def demonstrate_lattice_attacks():
    """Demonstrate lattice-based cryptography attacks."""
    print("=" * 60)
    print("Lattice-Based Cryptography Attacks")
    print("=" * 60)

    attacker = LatticeAttack(dimension=4)

    # Example 1: NTRU attack
    print("\n[*] Example 1: NTRU encryption attack")
    h = np.array([3, 7, 2, 5, 1, 8, 4, 6])  # Public key
    q = 11
    ciphertext = np.array([5, 3, 7, 2, 9, 1, 4, 8])

    result = attacker.attack_ntru(h, q, ciphertext)

    # Example 2: LWE attack
    print("\n[*] Example 2: LWE problem attack")
    n, m = 4, 8
    q = 97
    A = np.random.randint(0, q, (m, n))
    secret = np.random.randint(0, 3, n)
    error = np.random.randint(-1, 2, m)
    b = (A @ secret + error) % q

    result = attacker.attack_lwe(A, b, q, error_bound=2)

    # Example 3: CVP
    print("\n[*] Example 3: Closest Vector Problem")
    lattice_basis = np.array([[1, 0, 0], [0, 2, 0], [0, 0, 3]], dtype=float)
    target = np.array([1.7, 2.3, 4.1])

    result = attacker.solve_cvp(lattice_basis, target)

    print("\n" + "=" * 60)
    print("[+] Demonstrations complete")


if __name__ == "__main__":
    demonstrate_lattice_attacks()
