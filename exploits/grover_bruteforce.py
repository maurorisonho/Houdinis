#!/usr/bin/env python3
"""
Houdinis Framework - Grover Brute Force Ex                # Calculate hash with security warnings for weak algorithms
                if hash_type.lower() == 'md5':
                    print("[!] WARNING: MD5 is cryptographically weak. Use S            # Calculate hash with security warnings for weak algorithms
            if hash_type.lower() == 'md5':
                print("[!] WARNING: MD5 is cryptographically weak. Use SHA-256 or SHA-3 for security.")
                candidate_hash = hashlib.md5(candidate.encode()).hexdigest()
            elif hash_type.lower() == 'sha1':
                print("[!] WARNING: SHA-1 is cryptographically weak. Use SHA-256 or SHA-3 for security.")
                candidate_hash = hashlib.sha1(candidate.encode()).hexdigest()
            elif hash_type.lower() == 'sha256':
                candidate_hash = hashlib.sha256(candidate.encode()).hexdigest()
            elif hash_type.lower() == 'sha3_256':
                candidate_hash = hashlib.sha3_256(candidate.encode()).hexdigest()
            else:
                # Default to secure SHA-256
                print(f"[!] Unknown hash type '{hash_type}', using secure SHA-256")
                candidate_hash = hashlib.sha256(candidate.encode()).hexdigest() or SHA-3 for security.")
                    candidate_hash = hashlib.md5(candidate_str.encode()).hexdigest()
                elif hash_type.lower() == 'sha1':
                    print("[!] WARNING: SHA-1 is cryptographically weak. Use SHA-256 or SHA-3 for security.")
                    candidate_hash = hashlib.sha1(candidate_str.encode()).hexdigest()
                elif hash_type.lower() == 'sha256':
                    candidate_hash = hashlib.sha256(candidate_str.encode()).hexdigest()
                elif hash_type.lower() == 'sha3_256':
                    candidate_hash = hashlib.sha3_256(candidate_str.encode()).hexdigest()
                else:
                    # Default to secure SHA-256
                    print(f"[!] Unknown hash type '{hash_type}', using secure SHA-256")
                    candidate_hash = hashlib.sha256(candidate_str.encode()).hexdigest()Author: Mauro Risonho de Paula Assumpção aka firebitsbr
License: MIT

Implements Grover's algorithm for brute force attacks against
symmetric encryption keys, passwords, and hash preimages.
"""

import sys
import os

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit import transpile
    import numpy as np

    QUANTUM_AVAILABLE = True
except ImportError:
    QUANTUM_AVAILABLE = False
    print("  Quantum libraries not available, using classical simulation")

import hashlib
import itertools
import random
import time
from typing import Dict, List, Optional


class GroverBruteForceExploit:
    """Grover's algorithm for brute force attacks"""

    def __init__(self) -> None:
        self.name = "Grover Brute Force Exploit"
        self.description = "Quantum brute force attack using Grover's algorithm"
        self.author = "Mauro Risonho de Paula Assumpção aka firebitsbr"
        self.difficulty = "Intermediate"
        self.category = "quantum_cryptanalysis"

    def info(self) -> Dict:
        """Return exploit information"""
        return {
            "name": self.name,
            "description": self.description,
            "author": self.author,
            "difficulty": self.difficulty,
            "category": self.category,
            "target": "Symmetric keys, passwords, hash preimages",
            "quantum_algorithm": "Grover's search algorithm",
            "requirements": ["quantum_backend", "target_hash_or_ciphertext"],
        }

    def classical_brute_force(
        self, target_hash: str, hash_type: str, max_length: int
    ) -> Optional[str]:
        """Classical brute force attack for comparison"""
        print(f"[LOADING] Classical brute force attack...")

        charset = "abcdefghijklmnopqrstuvwxyz0123456789"
        attempts = 0
        max_attempts = 100000  # Limit for demo

        start_time = time.time()

        for length in range(1, max_length + 1):
            for candidate in itertools.product(charset, repeat=length):
                candidate_str = "".join(candidate)
                attempts += 1

                # Hash the candidate
                if hash_type.lower() == "md5":
                    candidate_hash = hashlib.md5(candidate_str.encode()).hexdigest()
                elif hash_type.lower() == "sha256":
                    candidate_hash = hashlib.sha256(candidate_str.encode()).hexdigest()
                else:
                    candidate_hash = hashlib.sha1(candidate_str.encode()).hexdigest()

                if candidate_hash == target_hash:
                    elapsed = time.time() - start_time
                    print(
                        f" Found: '{candidate_str}' after {attempts} attempts in {elapsed:.2f}s"
                    )
                    return candidate_str

                if attempts >= max_attempts:
                    print(f" Reached maximum attempts ({max_attempts})")
                    return None

        print(f" Not found after checking {attempts} combinations")
        return None

    def quantum_grover_search(
        self,
        target_hash: str,
        hash_type: str,
        search_space_bits: int,
        backend_type: str = "simulator",
    ) -> Optional[str]:
        """Quantum Grover's algorithm search"""
        print(f" Quantum Grover's algorithm search...")

        if not QUANTUM_AVAILABLE:
            print(" Quantum libraries not available")
            return None

        try:
            from quantum.backend import QuantumBackendManager

            backend_manager = QuantumBackendManager()

            backend = backend_manager.get_backend()
            if not backend:
                print(" No quantum backend available")
                return None

            # Limit search space for quantum simulation
            n_qubits = min(search_space_bits, 12)  # Limit to prevent simulation issues
            search_space_size = 2**n_qubits

            print(
                f"[TARGET] Search space: {search_space_size} possibilities ({n_qubits} qubits)"
            )

            # Create Grover circuit
            qc = self._create_grover_circuit(target_hash, hash_type, n_qubits)

            # Execute on quantum backend
            transpiled = transpile(qc, backend)
            job = backend.run(transpiled, shots=1024)
            result = job.result()
            counts = result.get_counts()

            # Process results
            candidate = self._process_grover_results(
                counts, target_hash, hash_type, n_qubits
            )

            if candidate:
                print(f" Quantum search found candidate: '{candidate}'")
                return candidate
            else:
                print(" Quantum search failed to find solution")
                return None

        except Exception as e:
            print(f" Quantum execution error: {e}")
            return None

    def _create_grover_circuit(
        self, target_hash: str, hash_type: str, n_qubits: int
    ) -> "QuantumCircuit":
        """Create Grover quantum circuit"""
        qreg = QuantumRegister(n_qubits, "q")
        creg = ClassicalRegister(n_qubits, "c")
        qc = QuantumCircuit(qreg, creg)

        # Initialize superposition
        qc.h(qreg)

        # Calculate optimal number of iterations
        search_space_size = 2**n_qubits
        optimal_iterations = int(np.pi * np.sqrt(search_space_size) / 4)

        print(f"[LOADING] Applying {optimal_iterations} Grover iterations")

        # Apply Grover iterations
        for _ in range(optimal_iterations):
            # Oracle (simplified - marks target state)
            self._apply_oracle(qc, qreg, target_hash, hash_type)

            # Diffusion operator
            self._apply_diffusion(qc, qreg)

        # Measurement
        qc.measure(qreg, creg)

        return qc

    def _apply_oracle(
        self,
        qc: "QuantumCircuit",
        qreg: "QuantumRegister",
        target_hash: str,
        hash_type: str,
    ):
        """Apply oracle that marks the target state"""
        # Simplified oracle implementation
        # In a real implementation, this would be a quantum hash function

        # For demonstration, we'll use a pattern-based oracle
        target_pattern = sum(int(c, 16) for c in target_hash[:4]) % (2 ** len(qreg))

        # Convert target pattern to binary
        target_bits = format(target_pattern, f"0{len(qreg)}b")

        # Apply X gates to flip qubits that should be 0 in target state
        for i, bit in enumerate(target_bits):
            if bit == "0":
                qc.x(qreg[i])

        # Multi-controlled Z gate (phase flip for target state)
        if len(qreg) > 1:
            qc.mcrz(np.pi, qreg[:-1], qreg[-1])
        else:
            qc.z(qreg[0])

        # Flip back the X gates
        for i, bit in enumerate(target_bits):
            if bit == "0":
                qc.x(qreg[i])

    def _apply_diffusion(self, qc: "QuantumCircuit", qreg: "QuantumRegister"):
        """Apply diffusion operator (inversion about average)"""
        # H gates
        qc.h(qreg)

        # X gates
        qc.x(qreg)

        # Multi-controlled Z gate
        if len(qreg) > 1:
            qc.mcrz(np.pi, qreg[:-1], qreg[-1])
        else:
            qc.z(qreg[0])

        # X gates
        qc.x(qreg)

        # H gates
        qc.h(qreg)

    def _process_grover_results(
        self, counts: Dict, target_hash: str, hash_type: str, n_qubits: int
    ) -> Optional[str]:
        """Process Grover algorithm results"""
        # Find most frequent measurement result
        max_count = 0
        best_result = None

        for bitstring, count in counts.items():
            if count > max_count:
                max_count = count
                best_result = bitstring

        if not best_result:
            return None

        # Convert bitstring to candidate string
        candidate_int = int(best_result, 2)
        candidate = self._int_to_string(candidate_int, n_qubits)

        # Verify candidate
        if self._verify_candidate(candidate, target_hash, hash_type):
            return candidate

        # Try variations around the best result
        for delta in range(-5, 6):
            test_int = (candidate_int + delta) % (2**n_qubits)
            test_candidate = self._int_to_string(test_int, n_qubits)
            if self._verify_candidate(test_candidate, target_hash, hash_type):
                return test_candidate

        return None

    def _int_to_string(self, value: int, max_bits: int) -> str:
        """Convert integer to candidate string"""
        # Simple mapping for demonstration
        charset = "abcdefghijklmnopqrstuvwxyz0123456789"
        result = ""

        while value > 0 and len(result) < 8:  # Max 8 characters
            result = charset[value % len(charset)] + result
            value //= len(charset)

        return result if result else "a"

    def _verify_candidate(
        self, candidate: str, target_hash: str, hash_type: str
    ) -> bool:
        """Verify if candidate produces target hash"""
        try:
            if hash_type.lower() == "md5":
                candidate_hash = hashlib.md5(candidate.encode()).hexdigest()
            elif hash_type.lower() == "sha256":
                candidate_hash = hashlib.sha256(candidate.encode()).hexdigest()
            else:
                candidate_hash = hashlib.sha1(candidate.encode()).hexdigest()

            return candidate_hash == target_hash
        except:
            return False

    def analyze_target(self, target_hash: str, hash_type: str) -> Dict:
        """Analyze the target for attack feasibility"""
        analysis = {
            "hash_type": hash_type,
            "hash_length": len(target_hash),
            "estimated_keyspace": "unknown",
            "quantum_advantage": "unknown",
            "classical_time": "unknown",
            "quantum_time": "unknown",
            "feasibility": "unknown",
        }

        # Estimate keyspace based on hash type and typical key lengths
        if hash_type.lower() == "md5":
            analysis["hash_length"] = 32
            analysis["estimated_keyspace"] = "2^128 (if random key)"
        elif hash_type.lower() == "sha256":
            analysis["hash_length"] = 64
            analysis["estimated_keyspace"] = "2^256 (if random key)"
        elif hash_type.lower() == "sha1":
            analysis["hash_length"] = 40
            analysis["estimated_keyspace"] = "2^160 (if random key)"

        # Estimate attack times (simplified)
        if len(target_hash) <= 32:  # Assuming shorter passwords
            analysis["classical_time"] = "2^64 operations (years on classical computer)"
            analysis["quantum_time"] = "2^32 operations (Grover speedup)"
            analysis["quantum_advantage"] = "Quadratic speedup"
            analysis["feasibility"] = "Potentially feasible with large quantum computer"
        else:
            analysis["classical_time"] = "2^128+ operations (infeasible)"
            analysis["quantum_time"] = "2^64+ operations (still very difficult)"
            analysis["quantum_advantage"] = "Quadratic speedup, but still challenging"
            analysis["feasibility"] = (
                "Requires very large fault-tolerant quantum computer"
            )

        return analysis

    def run(
        self,
        target_hash: str,
        hash_type: str = "md5",
        max_length: int = 6,
        backend_type: str = "simulator",
    ) -> Dict:
        """Run the Grover brute force exploit"""
        try:
            print(f"[TARGET] Grover Brute Force Exploit")
            print(f"=" * 50)
            print(f"Target hash: {target_hash}")
            print(f"Hash type: {hash_type.upper()}")
            print(f"Max length: {max_length}")

            # Analyze target
            analysis = self.analyze_target(target_hash, hash_type)

            print(f"\n Target Analysis:")
            print(f"   -  Hash type: {analysis['hash_type'].upper()}")
            print(f"   -  Estimated keyspace: {analysis['estimated_keyspace']}")
            print(f"   -  Quantum advantage: {analysis['quantum_advantage']}")
            print(f"   -  Feasibility: {analysis['feasibility']}")

            # Attempt quantum search first
            search_space_bits = min(
                max_length * 5, 12
            )  # Rough estimate, limited for simulation

            print(f"\n Attempting Grover quantum search...")
            quantum_result = self.quantum_grover_search(
                target_hash, hash_type, search_space_bits, backend_type
            )

            if quantum_result:
                # Verify quantum result
                if self._verify_candidate(quantum_result, target_hash, hash_type):
                    print(f" Quantum attack successful!")
                    return {
                        "success": True,
                        "method": "quantum_grover",
                        "result": quantum_result,
                        "target_hash": target_hash,
                        "hash_type": hash_type,
                        "analysis": analysis,
                    }

            # Fallback to classical brute force
            print(f"\n[LOADING] Attempting classical brute force (limited search)...")
            classical_result = self.classical_brute_force(
                target_hash, hash_type, max_length
            )

            if classical_result:
                print(f" Classical attack successful!")
                return {
                    "success": True,
                    "method": "classical_brute_force",
                    "result": classical_result,
                    "target_hash": target_hash,
                    "hash_type": hash_type,
                    "analysis": analysis,
                }
            else:
                print(f" Both quantum and classical attacks failed")
                return {
                    "success": False,
                    "error": "Target not found in search space",
                    "analysis": analysis,
                }

        except Exception as e:
            error_msg = f"Exploit execution error: {e}"
            print(f" {error_msg}")
            return {"success": False, "error": error_msg}


def main():
    """CLI interface for Grover brute force exploit"""
    if len(sys.argv) < 2:
        print(
            "Usage: python grover_bruteforce.py <target_hash> [hash_type] [max_length]"
        )
        print(
            "Example: python grover_bruteforce.py 5d41402abc4b2a76b9719d911017c592 md5 6"
        )
        print("Hash types: md5, sha1, sha256")
        sys.exit(1)

    target_hash = sys.argv[1]
    hash_type = sys.argv[2] if len(sys.argv) > 2 else "md5"
    max_length = int(sys.argv[3]) if len(sys.argv) > 3 else 6

    exploit = GroverBruteForceExploit()
    result = exploit.run(target_hash, hash_type, max_length)

    if result["success"]:
        print(f"\n[TARGET] Exploit completed successfully!")
        print(f"Found: {result['result']}")
        sys.exit(0)
    else:
        print(f"\n Exploit failed: {result.get('error', 'Unknown error')}")
        sys.exit(1)


if __name__ == "__main__":
    main()
