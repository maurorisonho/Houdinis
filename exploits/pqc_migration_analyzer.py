#!/usr/bin/env python3
"""
Post-Quantum Cryptography Migration Analyzer
=============================================

Automated tool for analyzing cryptographic systems and providing PQC migration
recommendations, vulnerability scanning, and migration path generation.

Features:
- Scan codebases for classical cryptographic usage
- Assess quantum vulnerability of current algorithms
- Generate automated migration recommendations
- Provide side-channel security analysis
- Create step-by-step migration paths
- Estimate migration complexity and timeline

Supported Classical Algorithms:
- RSA (key exchange, signatures)
- ECDH, ECDSA (elliptic curve)
- DSA, DH (discrete logarithm)

Recommended PQC Replacements:
- CRYSTALS-Kyber (KEM)
- CRYSTALS-Dilithium (signatures)
- FALCON (compact signatures)
- SPHINCS+ (stateless signatures)

Author: Houdinis Framework
License: MIT
"""

import re
import hashlib
import json
import time
from typing import Dict, List, Tuple, Optional, Any, Set
from dataclasses import dataclass, field
from collections import defaultdict
from pathlib import Path


@dataclass
class CryptoUsage:
    """Detected cryptographic algorithm usage"""

    algorithm: str
    location: str
    line_number: int
    context: str
    quantum_vulnerable: bool
    security_level: int  # Key size in bits
    usage_type: str  # "key_exchange", "signature", "encryption"


@dataclass
class MigrationRecommendation:
    """PQC migration recommendation"""

    current_algorithm: str
    recommended_pqc: str
    migration_strategy: str  # "direct_replacement", "hybrid", "gradual"
    priority: str  # "critical", "high", "medium", "low"
    estimated_effort: str  # "low", "medium", "high", "very_high"
    breaking_changes: bool
    compatibility_impact: str
    timeline_weeks: int


@dataclass
class VulnerabilityAssessment:
    """Security vulnerability assessment"""

    vulnerability_type: str
    severity: str  # "critical", "high", "medium", "low"
    affected_algorithms: List[str]
    quantum_threat_level: str  # "immediate", "near_term", "long_term"
    classical_security_bits: int
    quantum_security_bits: int
    mitigation: str


@dataclass
class MigrationPath:
    """Step-by-step migration path"""

    name: str
    description: str
    phases: List[Dict[str, Any]]
    total_duration_weeks: int
    required_resources: List[str]
    success_criteria: List[str]


class PQCMigrationAnalyzer:
    """
    Comprehensive PQC migration analysis and recommendation tool.

    Scans cryptographic usage, assesses vulnerabilities, and generates
    automated migration paths to post-quantum cryptography.
    """

    # Regex patterns for detecting cryptographic usage
    CRYPTO_PATTERNS = {
        "RSA": [
            r"\bRSA\b",
            r"RSAEncryption",
            r"RSAPublicKey",
            r"RSAPrivateKey",
            r"PKCS1",
            r"RSA_OAEP",
            r"RSA_PSS",
        ],
        "ECDH": [
            r"\bECDH\b",
            r"ECDHE",
            r"secp256r1",
            r"secp384r1",
            r"secp521r1",
            r"P-256",
            r"P-384",
            r"P-521",
            r"elliptic.*curve.*diffie",
        ],
        "ECDSA": [r"\bECDSA\b", r"ECDSASignature", r"ec.*signature"],
        "DH": [r"\bDH\b", r"DHE\b", r"Diffie.*Hellman", r"DiffieHellman"],
        "DSA": [r"\bDSA\b", r"DSASignature", r"Digital.*Signature.*Algorithm"],
    }

    # PQC algorithm recommendations
    PQC_RECOMMENDATIONS = {
        "RSA": {
            "key_exchange": "CRYSTALS-Kyber",
            "signature": "CRYSTALS-Dilithium",
            "encryption": "CRYSTALS-Kyber + symmetric",
        },
        "ECDH": {"key_exchange": "CRYSTALS-Kyber"},
        "ECDSA": {"signature": "CRYSTALS-Dilithium"},
        "DH": {"key_exchange": "CRYSTALS-Kyber"},
        "DSA": {"signature": "CRYSTALS-Dilithium"},
    }

    def __init__(self):
        """Initialize PQC migration analyzer"""
        self.crypto_usages: List[CryptoUsage] = []
        self.vulnerabilities: List[VulnerabilityAssessment] = []
        self.recommendations: List[MigrationRecommendation] = []
        self.migration_paths: List[MigrationPath] = []

    def scan_file(self, filepath: str) -> List[CryptoUsage]:
        """
        Scan a source file for cryptographic algorithm usage.

        Args:
            filepath: Path to source file

        Returns:
            List of detected crypto usage
        """
        print(f"[*] Scanning file: {filepath}")

        detected = []

        try:
            with open(filepath, "r", encoding="utf-8", errors="ignore") as f:
                lines = f.readlines()

            for line_num, line in enumerate(lines, 1):
                for algo, patterns in self.CRYPTO_PATTERNS.items():
                    for pattern in patterns:
                        if re.search(pattern, line, re.IGNORECASE):
                            usage = CryptoUsage(
                                algorithm=algo,
                                location=filepath,
                                line_number=line_num,
                                context=line.strip(),
                                quantum_vulnerable=True,  # All classical algos are vulnerable
                                security_level=self._estimate_security_level(
                                    algo, line
                                ),
                                usage_type=self._detect_usage_type(line),
                            )
                            detected.append(usage)
                            self.crypto_usages.append(usage)
                            print(
                                f"    [+] Detected {algo} at line {line_num}: {usage.usage_type}"
                            )
                            break  # Avoid multiple detections per line

        except Exception as e:
            print(f"    [!] Error scanning {filepath}: {e}")

        return detected

    def scan_directory(self, directory: str, extensions: List[str] = None) -> int:
        """
        Recursively scan directory for cryptographic usage.

        Args:
            directory: Root directory to scan
            extensions: File extensions to scan (default: common programming languages)

        Returns:
            Number of files scanned
        """
        if extensions is None:
            extensions = [
                ".py",
                ".java",
                ".c",
                ".cpp",
                ".h",
                ".js",
                ".ts",
                ".go",
                ".rs",
                ".rb",
            ]

        print(f"[*] Scanning directory: {directory}")
        print(f"[*] File extensions: {', '.join(extensions)}")

        files_scanned = 0
        path = Path(directory)

        for ext in extensions:
            for filepath in path.rglob(f"*{ext}"):
                if filepath.is_file():
                    self.scan_file(str(filepath))
                    files_scanned += 1

        print(f"[+] Scanned {files_scanned} files")
        print(f"[+] Detected {len(self.crypto_usages)} cryptographic usages")

        return files_scanned

    def assess_vulnerabilities(self) -> List[VulnerabilityAssessment]:
        """
        Assess quantum vulnerabilities of detected cryptographic usage.

        Returns:
            List of vulnerability assessments
        """
        print(f"\n[*] Assessing quantum vulnerabilities...")

        # Group usages by algorithm
        algo_groups = defaultdict(list)
        for usage in self.crypto_usages:
            algo_groups[usage.algorithm].append(usage)

        for algo, usages in algo_groups.items():
            # Assess vulnerability
            classical_bits = max([u.security_level for u in usages])
            quantum_bits = self._compute_quantum_security(algo, classical_bits)

            # Determine threat level
            if quantum_bits < 80:
                threat_level = "immediate"
                severity = "critical"
            elif quantum_bits < 112:
                threat_level = "near_term"
                severity = "high"
            else:
                threat_level = "long_term"
                severity = "medium"

            vulnerability = VulnerabilityAssessment(
                vulnerability_type=f"{algo} Quantum Vulnerability",
                severity=severity,
                affected_algorithms=[algo],
                quantum_threat_level=threat_level,
                classical_security_bits=classical_bits,
                quantum_security_bits=quantum_bits,
                mitigation=f"Migrate to {self.PQC_RECOMMENDATIONS[algo][usages[0].usage_type]}",
            )

            self.vulnerabilities.append(vulnerability)

            print(
                f"    [{severity.upper()}] {algo}: {classical_bits}-bit classical → {quantum_bits}-bit quantum"
            )
            print(
                f"                Threat: {threat_level}, Affected: {len(usages)} locations"
            )

        print(f"[+] Identified {len(self.vulnerabilities)} vulnerability categories")

        return self.vulnerabilities

    def generate_recommendations(self) -> List[MigrationRecommendation]:
        """
        Generate automated PQC migration recommendations.

        Returns:
            List of migration recommendations
        """
        print(f"\n[*] Generating migration recommendations...")

        # Group by algorithm and usage type
        usage_map = defaultdict(list)
        for usage in self.crypto_usages:
            key = (usage.algorithm, usage.usage_type)
            usage_map[key].append(usage)

        for (algo, usage_type), usages in usage_map.items():
            # Get PQC recommendation
            if algo in self.PQC_RECOMMENDATIONS:
                pqc_algo = self.PQC_RECOMMENDATIONS[algo].get(
                    usage_type, "CRYSTALS-Kyber"
                )
            else:
                pqc_algo = "CRYSTALS-Kyber"  # Default

            # Determine migration strategy
            num_usages = len(usages)
            avg_security = sum(u.security_level for u in usages) / num_usages

            if num_usages > 20 or avg_security < 2048:
                strategy = "hybrid"
                priority = "critical" if avg_security < 2048 else "high"
                timeline = 12
                effort = "high"
            elif num_usages > 5:
                strategy = "gradual"
                priority = "high" if avg_security < 2048 else "medium"
                timeline = 24
                effort = "medium"
            else:
                strategy = "direct_replacement"
                priority = "medium" if avg_security < 2048 else "low"
                timeline = 8
                effort = "low"

            recommendation = MigrationRecommendation(
                current_algorithm=f"{algo} ({usage_type})",
                recommended_pqc=pqc_algo,
                migration_strategy=strategy,
                priority=priority,
                estimated_effort=effort,
                breaking_changes=strategy == "direct_replacement",
                compatibility_impact="High" if num_usages > 10 else "Medium",
                timeline_weeks=timeline,
            )

            self.recommendations.append(recommendation)

            print(f"    [{priority.upper()}] {algo} → {pqc_algo}")
            print(
                f"            Strategy: {strategy}, Timeline: {timeline} weeks, Effort: {effort}"
            )

        print(f"[+] Generated {len(self.recommendations)} recommendations")

        return self.recommendations

    def create_migration_path(self, strategy: str = "hybrid") -> MigrationPath:
        """
        Create detailed step-by-step migration path.

        Args:
            strategy: Migration strategy ("direct_replacement", "hybrid", "gradual")

        Returns:
            Detailed migration path
        """
        print(f"\n[*] Creating {strategy} migration path...")

        if strategy == "hybrid":
            path = self._create_hybrid_migration_path()
        elif strategy == "gradual":
            path = self._create_gradual_migration_path()
        else:  # direct_replacement
            path = self._create_direct_migration_path()

        self.migration_paths.append(path)

        print(f"[+] Created migration path: {path.name}")
        print(f"    Total duration: {path.total_duration_weeks} weeks")
        print(f"    Phases: {len(path.phases)}")

        return path

    def perform_side_channel_analysis(self) -> Dict[str, Any]:
        """
        Analyze side-channel vulnerabilities in PQC transition.

        Returns:
            Dictionary containing side-channel analysis results
        """
        print(f"\n[*] Performing side-channel security analysis...")

        side_channel_risks = {
            "timing_attacks": [],
            "power_analysis": [],
            "cache_timing": [],
            "fault_injection": [],
        }

        for usage in self.crypto_usages:
            algo = usage.algorithm

            # Assess side-channel risks
            if algo in ["RSA", "ECDSA", "ECDH"]:
                side_channel_risks["timing_attacks"].append(
                    {
                        "location": usage.location,
                        "algorithm": algo,
                        "risk": "high",
                        "mitigation": "Use constant-time implementation",
                    }
                )

            if algo in ["RSA", "ECDH"]:
                side_channel_risks["power_analysis"].append(
                    {
                        "location": usage.location,
                        "algorithm": algo,
                        "risk": "medium",
                        "mitigation": "Implement power analysis countermeasures",
                    }
                )

            if algo in ["ECDH", "ECDSA"]:
                side_channel_risks["cache_timing"].append(
                    {
                        "location": usage.location,
                        "algorithm": algo,
                        "risk": "medium",
                        "mitigation": "Use cache-oblivious algorithms",
                    }
                )

        analysis = {
            "total_risks": sum(len(v) for v in side_channel_risks.values()),
            "risk_categories": {k: len(v) for k, v in side_channel_risks.items()},
            "high_risk_locations": [
                r["location"]
                for r in side_channel_risks["timing_attacks"]
                if r["risk"] == "high"
            ],
            "recommendations": [
                "Implement constant-time PQC algorithms",
                "Add side-channel countermeasures during migration",
                "Perform security audits of PQC implementations",
                "Use hardware security modules (HSMs) where possible",
            ],
        }

        print(f"[+] Side-channel analysis complete:")
        print(f"    Total risks identified: {analysis['total_risks']}")
        print(f"    High-risk locations: {len(analysis['high_risk_locations'])}")

        return analysis

    def generate_comprehensive_report(self) -> Dict[str, Any]:
        """
        Generate comprehensive PQC migration report.

        Returns:
            Complete migration analysis report
        """
        print(f"\n{'='*70}")
        print(f"Post-Quantum Cryptography Migration Report")
        print(f"{'='*70}\n")

        # Ensure analysis is complete
        if not self.vulnerabilities:
            self.assess_vulnerabilities()
        if not self.recommendations:
            self.generate_recommendations()
        if not self.migration_paths:
            self.create_migration_path("hybrid")

        side_channel = self.perform_side_channel_analysis()

        # Compile statistics
        algo_stats = defaultdict(int)
        for usage in self.crypto_usages:
            algo_stats[usage.algorithm] += 1

        priority_stats = defaultdict(int)
        for rec in self.recommendations:
            priority_stats[rec.priority] += 1

        # Calculate timeline
        total_timeline = (
            max([rec.timeline_weeks for rec in self.recommendations])
            if self.recommendations
            else 0
        )

        report = {
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "summary": {
                "total_crypto_usages": len(self.crypto_usages),
                "unique_algorithms": len(algo_stats),
                "algorithm_breakdown": dict(algo_stats),
                "total_vulnerabilities": len(self.vulnerabilities),
                "critical_vulnerabilities": len(
                    [v for v in self.vulnerabilities if v.severity == "critical"]
                ),
                "high_priority_recommendations": priority_stats.get("critical", 0)
                + priority_stats.get("high", 0),
            },
            "vulnerabilities": [
                {
                    "type": v.vulnerability_type,
                    "severity": v.severity,
                    "threat_level": v.quantum_threat_level,
                    "classical_security_bits": v.classical_security_bits,
                    "quantum_security_bits": v.quantum_security_bits,
                    "mitigation": v.mitigation,
                }
                for v in self.vulnerabilities
            ],
            "recommendations": [
                {
                    "current": r.current_algorithm,
                    "recommended": r.recommended_pqc,
                    "strategy": r.migration_strategy,
                    "priority": r.priority,
                    "effort": r.estimated_effort,
                    "timeline_weeks": r.timeline_weeks,
                    "breaking_changes": r.breaking_changes,
                }
                for r in self.recommendations
            ],
            "migration_paths": [
                {
                    "name": p.name,
                    "description": p.description,
                    "total_duration_weeks": p.total_duration_weeks,
                    "phases": len(p.phases),
                    "required_resources": p.required_resources,
                }
                for p in self.migration_paths
            ],
            "side_channel_analysis": side_channel,
            "estimated_migration": {
                "total_timeline_weeks": total_timeline,
                "recommended_start_date": "Q1 2025",
                "completion_target": f"Q{(total_timeline // 12) + 1} {2025 + (total_timeline // 52)}",
                "budget_estimate": self._estimate_migration_cost(),
                "team_size_recommendation": self._estimate_team_size(),
            },
        }

        print(f"Summary:")
        print(
            f"  Total cryptographic usages: {report['summary']['total_crypto_usages']}"
        )
        print(
            f"  Critical vulnerabilities: {report['summary']['critical_vulnerabilities']}"
        )
        print(
            f"  High priority recommendations: {report['summary']['high_priority_recommendations']}"
        )
        print(f"  Estimated timeline: {total_timeline} weeks")
        print(f"{'='*70}\n")

        return report

    def export_report(self, filename: str = None) -> str:
        """Export migration report to JSON file"""
        if filename is None:
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            filename = f"pqc_migration_report_{timestamp}.json"

        report = self.generate_comprehensive_report()

        with open(filename, "w") as f:
            json.dump(report, f, indent=2)

        print(f"[+] Report exported to: {filename}")
        return filename

    # Helper methods

    def _estimate_security_level(self, algorithm: str, context: str) -> int:
        """Estimate security level from context"""
        # Look for key size indicators
        if "4096" in context:
            return 4096
        elif "3072" in context:
            return 3072
        elif "2048" in context:
            return 2048
        elif "1024" in context:
            return 1024
        elif "521" in context or "P-521" in context:
            return 521
        elif "384" in context or "P-384" in context:
            return 384
        elif "256" in context or "P-256" in context:
            return 256
        else:
            # Default assumptions
            if algorithm == "RSA":
                return 2048
            elif algorithm in ["ECDH", "ECDSA"]:
                return 256
            else:
                return 2048

    def _detect_usage_type(self, context: str) -> str:
        """Detect crypto usage type from context"""
        context_lower = context.lower()

        if any(word in context_lower for word in ["sign", "verify", "signature"]):
            return "signature"
        elif any(word in context_lower for word in ["encrypt", "decrypt", "cipher"]):
            return "encryption"
        elif any(
            word in context_lower for word in ["exchange", "agreement", "ecdh", "dh"]
        ):
            return "key_exchange"
        else:
            return "unknown"

    def _compute_quantum_security(self, algorithm: str, classical_bits: int) -> int:
        """Compute equivalent quantum security"""
        if algorithm == "RSA":
            # Shor's algorithm: exponential speedup
            # RSA-2048 → ~0 bits quantum security
            return max(0, int(classical_bits * 0.01))
        elif algorithm in ["ECDH", "ECDSA"]:
            # ECDLP: similar to RSA
            # ECC-256 → ~0 bits quantum security
            return max(0, int(classical_bits * 0.01))
        elif algorithm in ["DH", "DSA"]:
            # Discrete log: exponential speedup
            return max(0, int(classical_bits * 0.01))
        else:
            return 0

    def _create_hybrid_migration_path(self) -> MigrationPath:
        """Create hybrid migration path"""
        phases = [
            {
                "name": "Phase 1: Assessment & Planning",
                "duration_weeks": 4,
                "tasks": [
                    "Complete cryptographic inventory",
                    "Assess quantum vulnerability",
                    "Select PQC algorithms",
                    "Design hybrid architecture",
                    "Create migration timeline",
                ],
            },
            {
                "name": "Phase 2: Infrastructure Preparation",
                "duration_weeks": 6,
                "tasks": [
                    "Deploy PQC libraries",
                    "Update key management systems",
                    "Implement hybrid protocol support",
                    "Setup testing environment",
                    "Train development team",
                ],
            },
            {
                "name": "Phase 3: Hybrid Deployment",
                "duration_weeks": 12,
                "tasks": [
                    "Implement hybrid key exchange (Classical + Kyber)",
                    "Deploy hybrid signatures (Classical + Dilithium)",
                    "Enable protocol negotiation",
                    "Gradual rollout to production",
                    "Monitor compatibility",
                ],
            },
            {
                "name": "Phase 4: Testing & Validation",
                "duration_weeks": 8,
                "tasks": [
                    "Security audit of hybrid implementation",
                    "Performance benchmarking",
                    "Interoperability testing",
                    "Side-channel analysis",
                    "Vulnerability assessment",
                ],
            },
            {
                "name": "Phase 5: PQC-Only Transition",
                "duration_weeks": 8,
                "tasks": [
                    "Deprecate classical-only support",
                    "Enforce PQC requirements",
                    "Final security audit",
                    "Update documentation",
                    "Complete migration",
                ],
            },
        ]

        return MigrationPath(
            name="Hybrid Classical-PQC Migration",
            description="Gradual migration using hybrid cryptography for maximum compatibility",
            phases=phases,
            total_duration_weeks=sum(p["duration_weeks"] for p in phases),
            required_resources=[
                "PQC development team (3-5 engineers)",
                "Security auditors",
                "PQC libraries (liboqs, etc.)",
                "Testing infrastructure",
                "Key management system upgrades",
            ],
            success_criteria=[
                "Zero downtime during migration",
                "Full backward compatibility maintained",
                "All quantum-vulnerable algorithms replaced",
                "Performance impact < 20%",
                "Security audit passed",
            ],
        )

    def _create_gradual_migration_path(self) -> MigrationPath:
        """Create gradual migration path"""
        phases = [
            {
                "name": "Phase 1: Low-Impact Services",
                "duration_weeks": 8,
                "tasks": ["Migrate non-critical services", "Test PQC implementation"],
            },
            {
                "name": "Phase 2: Medium-Impact Services",
                "duration_weeks": 12,
                "tasks": ["Migrate business services", "Monitor performance"],
            },
            {
                "name": "Phase 3: Critical Services",
                "duration_weeks": 16,
                "tasks": ["Migrate critical infrastructure", "Final validation"],
            },
        ]

        return MigrationPath(
            name="Gradual PQC Migration",
            description="Phased migration starting with low-impact services",
            phases=phases,
            total_duration_weeks=36,
            required_resources=["PQC team", "Testing resources"],
            success_criteria=["All services migrated", "No major incidents"],
        )

    def _create_direct_migration_path(self) -> MigrationPath:
        """Create direct replacement migration path"""
        phases = [
            {
                "name": "Phase 1: Preparation",
                "duration_weeks": 2,
                "tasks": ["Assess current usage", "Select PQC algorithms"],
            },
            {
                "name": "Phase 2: Implementation",
                "duration_weeks": 4,
                "tasks": ["Replace classical with PQC", "Update dependencies"],
            },
            {
                "name": "Phase 3: Deployment",
                "duration_weeks": 2,
                "tasks": ["Deploy to production", "Validate migration"],
            },
        ]

        return MigrationPath(
            name="Direct PQC Replacement",
            description="Fast direct replacement for simple use cases",
            phases=phases,
            total_duration_weeks=8,
            required_resources=["Development team"],
            success_criteria=["Migration complete", "Tests passing"],
        )

    def _estimate_migration_cost(self) -> str:
        """Estimate migration cost"""
        num_usages = len(self.crypto_usages)

        if num_usages < 10:
            return "$50K - $100K"
        elif num_usages < 50:
            return "$100K - $500K"
        elif num_usages < 200:
            return "$500K - $2M"
        else:
            return "$2M - $10M+"

    def _estimate_team_size(self) -> str:
        """Estimate required team size"""
        num_usages = len(self.crypto_usages)

        if num_usages < 10:
            return "1-2 engineers"
        elif num_usages < 50:
            return "3-5 engineers"
        elif num_usages < 200:
            return "5-10 engineers"
        else:
            return "10+ engineers"


def main():
    """Main demonstration"""
    print("Post-Quantum Cryptography Migration Analyzer")
    print("=" * 70)

    analyzer = PQCMigrationAnalyzer()

    # Example: Scan current directory
    analyzer.scan_directory(".", extensions=[".py"])

    # Generate comprehensive analysis
    report = analyzer.generate_comprehensive_report()

    # Export report
    analyzer.export_report()

    print("\n[+] Migration analysis complete!")


if __name__ == "__main__":
    main()
