#!/usr/bin/env python3
"""
Houdinis Framework - AES Quantum Assessment
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
Desenvolvido: Lógica e Codificação por Humano e AI Assistida (Claude Sonnet 4.5)
License: MIT

Assesses AES implementations for quantum vulnerabilities
and Grover's algorithm impact on symmetric encryption.
"""

import sys
import os

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import hashlib
import hmac
import struct
import secrets  # Secure random number generation
import time
from typing import Dict, List, Optional

# Use secure cryptography library instead of deprecated PyCrypto
try:
    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
    from cryptography.hazmat.primitives import padding
    from cryptography.hazmat.backends import default_backend

    CRYPTOGRAPHY_AVAILABLE = True
except ImportError:
    print(
        "[!] Warning: cryptography library not available. Install with: pip install cryptography>=41.0.0"
    )
    CRYPTOGRAPHY_AVAILABLE = False

# Fallback to PyCrypto with warning (deprecated)
if not CRYPTOGRAPHY_AVAILABLE:
    try:
        from Crypto.Cipher import AES
        from Crypto.Random import get_random_bytes
        from Crypto.Util.Padding import pad, unpad

        print(
            "[!] Warning: Using deprecated PyCrypto library. Please upgrade to cryptography library."
        )
    except ImportError:
        print(
            "[!] Error: No cryptographic library available. Install cryptography with: pip install cryptography>=41.0.0"
        )
        sys.exit(1)


class AESQuantumAssessment:
    """AES quantum vulnerability assessment tool"""

    def __init__(self) -> None:
        self.name = "AES Quantum Assessment"
        self.description = "Assess AES implementations for quantum vulnerabilities"
        self.author = "Mauro Risonho de Paula Assumpção aka firebitsbr"
        self.difficulty = "Intermediate"
        self.category = "quantum_assessment"

    def info(self) -> Dict:
        """Return assessment tool information"""
        return {
            "name": self.name,
            "description": self.description,
            "author": self.author,
            "difficulty": self.difficulty,
            "category": self.category,
            "target": "AES symmetric encryption implementations",
            "quantum_threat": "Grover's algorithm reduces effective key length by half",
            "requirements": ["aes_encrypted_data", "key_derivation_analysis"],
        }

    def get_aes_security_levels(self) -> Dict:
        """Get AES security levels in classical vs quantum scenarios"""
        return {
            "AES-128": {
                "key_size": 128,
                "classical_security": 128,
                "quantum_security": 64,  # Grover's algorithm halves security
                "break_timeline": "2040-2050",
                "risk_level": "MEDIUM",
                "status": "Quantum-vulnerable",
                "recommendation": "Upgrade to AES-256 or post-quantum",
            },
            "AES-192": {
                "key_size": 192,
                "classical_security": 192,
                "quantum_security": 96,
                "break_timeline": "2050-2060",
                "risk_level": "LOW",
                "status": "Quantum-resistant (medium-term)",
                "recommendation": "Monitor developments, plan migration",
            },
            "AES-256": {
                "key_size": 256,
                "classical_security": 256,
                "quantum_security": 128,
                "break_timeline": "2060+",
                "risk_level": "LOW",
                "status": "Quantum-resistant",
                "recommendation": "Acceptable for medium-term use",
            },
        }

    def analyze_aes_mode(self, mode: str) -> Dict:
        """Analyze AES mode of operation for quantum implications"""
        modes_analysis = {
            "ECB": {
                "security": "WEAK",
                "quantum_impact": "HIGH",
                "vulnerabilities": [
                    "Pattern exposure in ciphertext",
                    "Parallel Grover attacks possible",
                    "No semantic security",
                ],
                "recommendation": "Never use ECB mode",
            },
            "CBC": {
                "security": "MODERATE",
                "quantum_impact": "MEDIUM",
                "vulnerabilities": [
                    "IV reuse attacks",
                    "Padding oracle attacks",
                    "Sequential decryption under quantum attack",
                ],
                "recommendation": "Use with proper IV generation",
            },
            "CTR": {
                "security": "GOOD",
                "quantum_impact": "MEDIUM",
                "vulnerabilities": [
                    "Nonce reuse catastrophic",
                    "Parallel Grover attacks on keystream",
                ],
                "recommendation": "Ensure unique nonces",
            },
            "GCM": {
                "security": "EXCELLENT",
                "quantum_impact": "LOW",
                "vulnerabilities": [
                    "Nonce reuse breaks authentication",
                    "Quantum attacks on GHASH",
                ],
                "recommendation": "Preferred mode for new implementations",
            },
            "CCM": {
                "security": "GOOD",
                "quantum_impact": "LOW",
                "vulnerabilities": ["Nonce management critical"],
                "recommendation": "Good alternative to GCM",
            },
        }

        return modes_analysis.get(
            mode.upper(),
            {
                "security": "UNKNOWN",
                "quantum_impact": "UNKNOWN",
                "vulnerabilities": ["Unknown mode"],
                "recommendation": "Use standard modes like GCM",
            },
        )

    def simulate_grover_attack(
        self, key_size: int, known_plaintext: bytes = None
    ) -> Dict:
        """Simulate Grover's algorithm attack against AES key"""
        print(f" Simulating Grover's algorithm attack on AES-{key_size}")

        # Calculate attack complexity
        classical_operations = 2**key_size
        quantum_operations = 2 ** (key_size // 2)  # Grover's quadratic speedup

        # Estimate attack times (very rough estimates)
        classical_years = classical_operations / (
            10**12 * 365 * 24 * 3600
        )  # Assuming 1 THz
        quantum_seconds = quantum_operations / (
            10**6
        )  # Assuming 1 MHz quantum computer

        attack_analysis = {
            "key_size": key_size,
            "classical_operations": classical_operations,
            "quantum_operations": quantum_operations,
            "speedup_factor": classical_operations / quantum_operations,
            "classical_time_years": classical_years,
            "quantum_time_seconds": quantum_seconds,
            "feasibility": "INFEASIBLE",
            "quantum_computer_requirements": "Unknown",
        }

        if key_size == 128:
            attack_analysis["feasibility"] = "THEORETICALLY_POSSIBLE"
            attack_analysis["quantum_computer_requirements"] = "~3000 logical qubits"
        elif key_size == 192:
            attack_analysis["feasibility"] = "VERY_DIFFICULT"
            attack_analysis["quantum_computer_requirements"] = "~4500 logical qubits"
        elif key_size == 256:
            attack_analysis["feasibility"] = "EXTREMELY_DIFFICULT"
            attack_analysis["quantum_computer_requirements"] = "~6000 logical qubits"

        print(f"   -  Classical operations: 2^{key_size} = {classical_operations:.2e}")
        print(f"   -  Quantum operations: 2^{key_size//2} = {quantum_operations:.2e}")
        print(f"   -  Speedup factor: {attack_analysis['speedup_factor']:.2e}")
        print(f"   -  Feasibility: {attack_analysis['feasibility']}")

        return attack_analysis

    def analyze_key_derivation(self, password: str, salt: bytes = None) -> Dict:
        """Analyze key derivation function quantum resistance"""
        if salt is None:
            salt = get_random_bytes(16)

        print(f" Analyzing key derivation for password: '{password}'")

        # Test different KDF methods
        kdf_analysis = {}

        # PBKDF2
        start_time = time.time()
        iterations = 100000
        pbkdf2_key = hashlib.pbkdf2_hmac("sha256", password.encode(), salt, iterations)
        pbkdf2_time = time.time() - start_time

        kdf_analysis["PBKDF2"] = {
            "iterations": iterations,
            "time_seconds": pbkdf2_time,
            "quantum_resistance": "MODERATE",
            "grover_impact": "Reduces effective security by half",
            "recommendation": "Increase iterations for quantum era",
        }

        # Simple hash (weak)
        start_time = time.time()
        simple_key = hashlib.sha256(password.encode() + salt).digest()
        simple_time = time.time() - start_time

        kdf_analysis["Simple_Hash"] = {
            "iterations": 1,
            "time_seconds": simple_time,
            "quantum_resistance": "WEAK",
            "grover_impact": "Direct Grover attack on password space",
            "recommendation": "Never use for key derivation",
        }

        return kdf_analysis

    def test_aes_implementation(
        self, key_size: int, mode: str, plaintext: bytes
    ) -> Dict:
        """Test specific AES implementation for quantum vulnerabilities"""
        print(f" Testing AES-{key_size} in {mode} mode")

        try:
            # Generate random key
            key = get_random_bytes(key_size // 8)

            # Test encryption/decryption
            if mode.upper() == "GCM":
                cipher = AES.new(key, AES.MODE_GCM)
                ciphertext, tag = cipher.encrypt_and_digest(plaintext)
                nonce = cipher.nonce

                # Decrypt
                decipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
                decrypted = decipher.decrypt_and_verify(ciphertext, tag)

            elif mode.upper() == "CBC":
                iv = get_random_bytes(16)
                cipher = AES.new(key, AES.MODE_CBC, iv)
                padded_plaintext = pad(plaintext, AES.block_size)
                ciphertext = cipher.encrypt(padded_plaintext)

                # Decrypt
                decipher = AES.new(key, AES.MODE_CBC, iv)
                decrypted = unpad(decipher.decrypt(ciphertext), AES.block_size)

            else:
                return {"error": f"Unsupported mode: {mode}"}

            # Verify decryption
            success = decrypted == plaintext

            # Get security analysis
            security_info = self.get_aes_security_levels().get(f"AES-{key_size}", {})
            mode_info = self.analyze_aes_mode(mode)

            result = {
                "key_size": key_size,
                "mode": mode,
                "encryption_success": success,
                "ciphertext_size": len(ciphertext),
                "security_analysis": security_info,
                "mode_analysis": mode_info,
                "quantum_assessment": self.simulate_grover_attack(key_size),
            }

            print(f"   -  Encryption: {' Success' if success else ' Failed'}")
            print(
                f"   -  Quantum security level: {security_info.get('quantum_security', 'Unknown')} bits"
            )
            print(f"   -  Risk level: {security_info.get('risk_level', 'Unknown')}")

            return result

        except Exception as e:
            return {"error": f"Test failed: {e}"}

    def comprehensive_aes_assessment(self, test_data: bytes = None) -> Dict:
        """Perform comprehensive AES quantum assessment"""
        if test_data is None:
            test_data = b"Houdinis test data for AES assessment - " * 3

        print(f" Comprehensive AES Quantum Assessment")
        print(f"=" * 50)

        assessment_results = {
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "test_data_size": len(test_data),
            "aes_variants": {},
            "overall_recommendations": [],
            "quantum_readiness_score": 0.0,
        }

        # Test different AES configurations
        configurations = [
            (128, "CBC"),
            (128, "GCM"),
            (192, "CBC"),
            (192, "GCM"),
            (256, "CBC"),
            (256, "GCM"),
        ]

        total_score = 0
        for key_size, mode in configurations:
            print(f"\n Testing AES-{key_size} {mode}")
            result = self.test_aes_implementation(key_size, mode, test_data)

            if "error" not in result:
                assessment_results["aes_variants"][f"AES-{key_size}-{mode}"] = result

                # Calculate score based on quantum resistance
                variant_score = 0
                if key_size >= 256:
                    variant_score += 4
                elif key_size >= 192:
                    variant_score += 2
                else:
                    variant_score += 1

                if mode.upper() == "GCM":
                    variant_score += 2
                elif mode.upper() == "CBC":
                    variant_score += 1

                total_score += variant_score

        # Calculate overall quantum readiness score
        max_possible_score = len(configurations) * 6  # Max score per configuration
        assessment_results["quantum_readiness_score"] = (
            total_score / max_possible_score
        ) * 100

        # Generate recommendations
        if assessment_results["quantum_readiness_score"] < 50:
            assessment_results["overall_recommendations"] = [
                "CRITICAL: Upgrade to AES-256 immediately",
                "Use authenticated encryption modes (GCM)",
                "Implement post-quantum key exchange",
                "Plan migration to post-quantum symmetric crypto",
            ]
        elif assessment_results["quantum_readiness_score"] < 80:
            assessment_results["overall_recommendations"] = [
                "Upgrade AES-128 implementations to AES-256",
                "Prefer GCM mode over CBC",
                "Monitor post-quantum cryptography standards",
                "Implement crypto-agility",
            ]
        else:
            assessment_results["overall_recommendations"] = [
                "Current AES implementations are quantum-resistant",
                "Continue monitoring quantum developments",
                "Plan for eventual post-quantum migration",
                "Maintain crypto-agility",
            ]

        return assessment_results

    def generate_assessment_report(self, assessment_results: Dict) -> str:
        """Generate detailed assessment report"""
        report = f"""
[SECURITY] AES QUANTUM VULNERABILITY ASSESSMENT REPORT
===============================================

 ASSESSMENT SUMMARY:
   -  Timestamp: {assessment_results.get('timestamp', 'Unknown')}
   -  Test data size: {assessment_results.get('test_data_size', 0)} bytes
   -  Quantum readiness score: {assessment_results.get('quantum_readiness_score', 0):.1f}%

 AES VARIANT ANALYSIS:
"""

        for variant, results in assessment_results.get("aes_variants", {}).items():
            security = results.get("security_analysis", {})
            quantum_assessment = results.get("quantum_assessment", {})

            report += f"""
  {variant}:
     -  Classical security: {security.get('classical_security', 'Unknown')} bits
     -  Quantum security: {security.get('quantum_security', 'Unknown')} bits
     -  Risk level: {security.get('risk_level', 'Unknown')}
     -  Break timeline: {security.get('break_timeline', 'Unknown')}
     -  Grover operations needed: 2^{quantum_assessment.get('key_size', 0)//2}
     -  Feasibility: {quantum_assessment.get('feasibility', 'Unknown')}
"""

        report += f"""
[TARGET] RECOMMENDATIONS:
"""
        for rec in assessment_results.get("overall_recommendations", []):
            report += f"   -  {rec}\n"

        report += f"""
 QUANTUM THREAT ANALYSIS:
   -  AES-128: Reduced to 64-bit effective security (vulnerable by 2040-2050)
   -  AES-192: Reduced to 96-bit effective security (secure until 2050-2060)
   -  AES-256: Reduced to 128-bit effective security (secure beyond 2060)

  GROVER'S ALGORITHM IMPACT:
   -  Quadratic speedup against symmetric encryption
   -  Effectively halves key length security
   -  Requires large fault-tolerant quantum computers
   -  Timeline depends on quantum hardware development

  MITIGATION STRATEGIES:
  1. Upgrade AES-128 to AES-256 immediately
  2. Use authenticated encryption modes (GCM/CCM)
  3. Implement strong key derivation functions
  4. Plan migration to post-quantum symmetric algorithms
  5. Maintain crypto-agility for rapid algorithm updates

[LEGAL]  LEGAL NOTICE:
This assessment is for authorized security testing only.
Results should be used to improve cryptographic security.
"""

        return report

    def run(
        self, test_mode: str = "comprehensive", key_size: int = None, mode: str = None
    ) -> Dict:
        """Run AES quantum assessment"""
        try:
            print(f"[SECURITY] AES Quantum Assessment Tool")
            print(f"=" * 50)

            if test_mode == "comprehensive":
                # Comprehensive assessment
                results = self.comprehensive_aes_assessment()
                report = self.generate_assessment_report(results)

                print(f"\n Assessment Complete!")
                print(
                    f"   -  Quantum readiness score: {results['quantum_readiness_score']:.1f}%"
                )
                print(f"   -  Variants tested: {len(results['aes_variants'])}")

                return {
                    "success": True,
                    "mode": "comprehensive",
                    "results": results,
                    "report": report,
                }

            elif test_mode == "single" and key_size and mode:
                # Single variant test
                test_data = b"Test data for AES quantum assessment"
                result = self.test_aes_implementation(key_size, mode, test_data)

                if "error" in result:
                    return {"success": False, "error": result["error"]}

                print(f"\n[TARGET] Single variant test complete!")
                return {"success": True, "mode": "single", "result": result}
            else:
                return {
                    "success": False,
                    "error": "Invalid test mode or missing parameters",
                }

        except Exception as e:
            error_msg = f"Assessment error: {e}"
            print(f" {error_msg}")
            return {"success": False, "error": error_msg}


def main():
    """CLI interface for AES quantum assessment"""
    if len(sys.argv) < 2:
        print("Usage: python aes_assessment.py <mode> [options]")
        print("Modes:")
        print("  comprehensive - Full AES quantum assessment")
        print("  single <key_size> <mode> - Test specific AES variant")
        print("Examples:")
        print("  python aes_assessment.py comprehensive")
        print("  python aes_assessment.py single 256 GCM")
        sys.exit(1)

    test_mode = sys.argv[1]

    assessment = AESQuantumAssessment()

    if test_mode == "comprehensive":
        result = assessment.run("comprehensive")
    elif test_mode == "single" and len(sys.argv) == 4:
        key_size = int(sys.argv[2])
        mode = sys.argv[3]
        result = assessment.run("single", key_size, mode)
    else:
        print(" Invalid arguments")
        sys.exit(1)

    if result["success"]:
        print(f"\n[TARGET] Assessment completed successfully!")

        if "report" in result:
            print("\n" + result["report"])

        sys.exit(0)
    else:
        print(f"\n Assessment failed: {result.get('error', 'Unknown error')}")
        sys.exit(1)


if __name__ == "__main__":
    main()
