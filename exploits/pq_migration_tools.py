#!/usr/bin/env python3
"""
Post-Quantum Migration Tools
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
Developed by: Human Logic & Coding with AI Assistance (Claude Sonnet 4.5)
License: MIT

Tools for assessing and planning migration to post-quantum cryptography
"""

import sys
import os
import re
import json
import argparse
import time
import hashlib
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any

try:
    from qiskit import QuantumCircuit, transpile
    from qiskit.providers.aer import AerSimulator
    import numpy as np

    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False

try:
    import yaml

    YAML_AVAILABLE = True
except ImportError:
    YAML_AVAILABLE = False


class PostQuantumMigrationTools:
    """Post-Quantum Cryptography Migration Assessment and Planning Tools"""

    def __init__(self) -> None:
        self.quantum_vulnerable_patterns = {
            # RSA patterns
            r"rsa[-_]?\d+": {
                "algorithm": "RSA",
                "vulnerable": True,
                "category": "signature",
            },
            r"rsa[-_]?oaep": {
                "algorithm": "RSA-OAEP",
                "vulnerable": True,
                "category": "encryption",
            },
            r"rsa[-_]?pss": {
                "algorithm": "RSA-PSS",
                "vulnerable": True,
                "category": "signature",
            },
            r"rsa[-_]?pkcs": {
                "algorithm": "RSA-PKCS",
                "vulnerable": True,
                "category": "signature",
            },
            # ECDSA/ECDH patterns
            r"ecdsa[-_]?\w*": {
                "algorithm": "ECDSA",
                "vulnerable": True,
                "category": "signature",
            },
            r"ecdh[-_]?\w*": {
                "algorithm": "ECDH",
                "vulnerable": True,
                "category": "key_exchange",
            },
            r"secp\d+[kr]\d+": {
                "algorithm": "ECDSA/ECDH",
                "vulnerable": True,
                "category": "elliptic_curve",
            },
            r"prime\d+v\d+": {
                "algorithm": "ECDSA/ECDH",
                "vulnerable": True,
                "category": "elliptic_curve",
            },
            r"ed25519": {
                "algorithm": "Ed25519",
                "vulnerable": True,
                "category": "signature",
            },
            r"curve25519": {
                "algorithm": "Curve25519",
                "vulnerable": True,
                "category": "key_exchange",
            },
            # DSA patterns
            r"dsa[-_]?\d*": {
                "algorithm": "DSA",
                "vulnerable": True,
                "category": "signature",
            },
            # DH patterns
            r"diffie[-_]?hellman": {
                "algorithm": "Diffie-Hellman",
                "vulnerable": True,
                "category": "key_exchange",
            },
            r"dh[-_]?group[-_]?\d+": {
                "algorithm": "DH-Group",
                "vulnerable": True,
                "category": "key_exchange",
            },
            r"modp[-_]?\d+": {
                "algorithm": "MODP",
                "vulnerable": True,
                "category": "key_exchange",
            },
            # Symmetric (Grover-vulnerable)
            r"aes[-_]?128": {
                "algorithm": "AES-128",
                "vulnerable": True,
                "category": "symmetric",
            },
            r"3des": {"algorithm": "3DES", "vulnerable": True, "category": "symmetric"},
            r"des": {"algorithm": "DES", "vulnerable": True, "category": "symmetric"},
            # Hash functions (Grover-vulnerable)
            r"sha[-_]?1": {
                "algorithm": "SHA-1",
                "vulnerable": True,
                "category": "hash",
            },
            r"md5": {"algorithm": "MD5", "vulnerable": True, "category": "hash"},
            r"sha[-_]?224": {
                "algorithm": "SHA-224",
                "vulnerable": True,
                "category": "hash",
            },
            r"sha[-_]?256": {
                "algorithm": "SHA-256",
                "vulnerable": True,
                "category": "hash",
            },
        }

        self.post_quantum_replacements = {
            "signature": {
                "RSA": ["CRYSTALS-Dilithium", "FALCON", "SPHINCS+"],
                "ECDSA": ["CRYSTALS-Dilithium", "FALCON"],
                "Ed25519": ["CRYSTALS-Dilithium", "SPHINCS+"],
                "DSA": ["CRYSTALS-Dilithium", "SPHINCS+"],
            },
            "encryption": {
                "RSA-OAEP": ["CRYSTALS-Kyber", "Classic McEliece", "NTRU"],
                "ECDH": ["CRYSTALS-Kyber", "SIKE"],
                "Curve25519": ["CRYSTALS-Kyber"],
            },
            "key_exchange": {
                "Diffie-Hellman": ["CRYSTALS-Kyber", "Classic McEliece"],
                "ECDH": ["CRYSTALS-Kyber", "SIKE"],
                "DH-Group": ["CRYSTALS-Kyber"],
            },
            "symmetric": {
                "AES-128": ["AES-256", "ChaCha20"],
                "3DES": ["AES-256"],
                "DES": ["AES-256"],
            },
            "hash": {
                "SHA-1": ["SHA-3", "BLAKE3"],
                "MD5": ["SHA-3", "BLAKE3"],
                "SHA-224": ["SHA-384", "SHA-3-384"],
                "SHA-256": ["SHA-384", "SHA-3-384"],
            },
        }

        self.nist_approved_algorithms = {
            "signatures": {
                "CRYSTALS-Dilithium": {
                    "status": "NIST Standard",
                    "security_levels": [2, 3, 5],
                    "key_sizes": ["Dilithium2", "Dilithium3", "Dilithium5"],
                    "performance": "Fast",
                },
                "FALCON": {
                    "status": "NIST Standard",
                    "security_levels": [1, 5],
                    "key_sizes": ["FALCON-512", "FALCON-1024"],
                    "performance": "Compact signatures",
                },
                "SPHINCS+": {
                    "status": "NIST Standard",
                    "security_levels": [1, 3, 5],
                    "key_sizes": ["SPHINCS+-128s", "SPHINCS+-192s", "SPHINCS+-256s"],
                    "performance": "Stateless, larger signatures",
                },
            },
            "encryption": {
                "CRYSTALS-Kyber": {
                    "status": "NIST Standard",
                    "security_levels": [1, 3, 5],
                    "key_sizes": ["Kyber-512", "Kyber-768", "Kyber-1024"],
                    "performance": "Fast, small keys",
                },
                "Classic McEliece": {
                    "status": "NIST Standard",
                    "security_levels": [1, 3, 5],
                    "key_sizes": [
                        "mceliece348864",
                        "mceliece460896",
                        "mceliece6960119",
                    ],
                    "performance": "Large keys, conservative security",
                },
            },
        }

    def scan_file_for_crypto(self, file_path: str) -> Dict:
        """Scan a file for cryptographic algorithm usage"""
        results = {
            "file_path": file_path,
            "vulnerable_algorithms": [],
            "total_matches": 0,
            "categories": {},
            "recommendations": [],
        }

        try:
            # Determine file type and read appropriately
            if file_path.endswith(
                (".py", ".java", ".cpp", ".c", ".js", ".ts", ".go", ".rs")
            ):
                with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                    content = f.read().lower()
            elif file_path.endswith((".conf", ".config", ".cfg", ".ini")):
                with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                    content = f.read().lower()
            elif file_path.endswith((".xml", ".json", ".yaml", ".yml")):
                with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                    content = f.read().lower()
            else:
                # Try to read as text
                with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                    content = f.read().lower()

            # Search for vulnerable algorithms
            for pattern, info in self.quantum_vulnerable_patterns.items():
                matches = re.findall(pattern, content, re.IGNORECASE)

                if matches:
                    algorithm_info = {
                        "algorithm": info["algorithm"],
                        "category": info["category"],
                        "matches": len(matches),
                        "pattern": pattern,
                        "examples": list(set(matches))[:5],  # First 5 unique matches
                    }

                    results["vulnerable_algorithms"].append(algorithm_info)
                    results["total_matches"] += len(matches)

                    # Categorize
                    category = info["category"]
                    if category not in results["categories"]:
                        results["categories"][category] = 0
                    results["categories"][category] += len(matches)

                    # Generate recommendations
                    replacements = self.post_quantum_replacements.get(category, {}).get(
                        info["algorithm"], []
                    )
                    if replacements:
                        results["recommendations"].append(
                            {
                                "algorithm": info["algorithm"],
                                "replacements": replacements,
                            }
                        )

        except Exception as e:
            results["error"] = str(e)

        return results

    def scan_directory(self, directory: str, file_extensions: List[str] = None) -> Dict:
        """Recursively scan directory for cryptographic usage"""
        if file_extensions is None:
            file_extensions = [
                ".py",
                ".java",
                ".cpp",
                ".c",
                ".js",
                ".ts",
                ".go",
                ".rs",
                ".conf",
                ".config",
                ".cfg",
                ".ini",
                ".xml",
                ".json",
                ".yaml",
                ".yml",
            ]

        results = {
            "directory": directory,
            "files_scanned": 0,
            "vulnerable_files": 0,
            "total_vulnerabilities": 0,
            "files": {},
            "summary": {},
        }

        try:
            for root, dirs, files in os.walk(directory):
                for file in files:
                    if any(file.endswith(ext) for ext in file_extensions):
                        file_path = os.path.join(root, file)
                        relative_path = os.path.relpath(file_path, directory)

                        print(f" Scanning: {relative_path}")

                        file_results = self.scan_file_for_crypto(file_path)
                        results["files_scanned"] += 1

                        if file_results["vulnerable_algorithms"]:
                            results["vulnerable_files"] += 1
                            results["total_vulnerabilities"] += file_results[
                                "total_matches"
                            ]
                            results["files"][relative_path] = file_results

        except Exception as e:
            results["error"] = str(e)

        # Generate summary
        category_summary = {}
        algorithm_summary = {}

        for file_path, file_data in results["files"].items():
            for vuln in file_data["vulnerable_algorithms"]:
                category = vuln["category"]
                algorithm = vuln["algorithm"]

                if category not in category_summary:
                    category_summary[category] = 0
                category_summary[category] += vuln["matches"]

                if algorithm not in algorithm_summary:
                    algorithm_summary[algorithm] = 0
                algorithm_summary[algorithm] += vuln["matches"]

        results["summary"] = {
            "by_category": category_summary,
            "by_algorithm": algorithm_summary,
        }

        return results

    def generate_migration_plan(self, scan_results: Dict) -> Dict:
        """Generate detailed migration plan based on scan results"""
        plan = {
            "assessment": {
                "total_files": scan_results["files_scanned"],
                "vulnerable_files": scan_results["vulnerable_files"],
                "risk_level": "LOW",
            },
            "phases": {},
            "recommendations": [],
            "timeline": {},
            "resources": {},
        }

        # Assess risk level
        vulnerability_ratio = scan_results["vulnerable_files"] / max(
            scan_results["files_scanned"], 1
        )
        total_vulns = scan_results["total_vulnerabilities"]

        if vulnerability_ratio > 0.5 or total_vulns > 100:
            plan["assessment"]["risk_level"] = "HIGH"
        elif vulnerability_ratio > 0.2 or total_vulns > 20:
            plan["assessment"]["risk_level"] = "MEDIUM"

        # Phase 1: Immediate (0-6 months)
        plan["phases"]["phase_1"] = {
            "title": "Assessment and Planning",
            "duration": "0-6 months",
            "priority": "HIGH",
            "tasks": [
                "Complete cryptographic inventory",
                "Identify critical systems and data flows",
                "Assess quantum threat timeline",
                "Develop migration strategy",
                "Establish crypto-agility principles",
            ],
        }

        # Phase 2: Short-term (6-18 months)
        plan["phases"]["phase_2"] = {
            "title": "Interim Hardening",
            "duration": "6-18 months",
            "priority": "HIGH",
            "tasks": [
                "Increase key sizes for classical algorithms",
                "Disable weak algorithms (DES, 3DES, MD5, SHA-1)",
                "Implement hybrid classical+post-quantum solutions",
                "Update libraries and frameworks",
                "Begin pilot deployments of PQ algorithms",
            ],
        }

        # Phase 3: Medium-term (18-36 months)
        plan["phases"]["phase_3"] = {
            "title": "Post-Quantum Deployment",
            "duration": "18-36 months",
            "priority": "MEDIUM",
            "tasks": [
                "Deploy NIST-approved post-quantum algorithms",
                "Migrate critical applications",
                "Update protocols and standards",
                "Train development and operations teams",
                "Establish PQ key management",
            ],
        }

        # Phase 4: Long-term (36+ months)
        plan["phases"]["phase_4"] = {
            "title": "Full Migration and Optimization",
            "duration": "36+ months",
            "priority": "MEDIUM",
            "tasks": [
                "Complete migration of all systems",
                "Retire all quantum-vulnerable algorithms",
                "Optimize post-quantum implementations",
                "Regular security assessments",
                "Monitor quantum computing developments",
            ],
        }

        # Generate specific recommendations
        summary = scan_results.get("summary", {})

        for category, count in summary.get("by_category", {}).items():
            if category in self.post_quantum_replacements:
                plan["recommendations"].append(
                    {
                        "category": category,
                        "finding": f"{count} instances of quantum-vulnerable {category} algorithms",
                        "action": f"Replace with post-quantum {category} algorithms",
                        "priority": "HIGH" if count > 10 else "MEDIUM",
                    }
                )

        # Timeline
        plan["timeline"] = {
            "start_date": time.strftime("%Y-%m-%d"),
            "phase_1_end": self._add_months(6),
            "phase_2_end": self._add_months(18),
            "phase_3_end": self._add_months(36),
            "full_migration": self._add_months(48),
        }

        # Resource requirements
        plan["resources"] = {
            "personnel": {
                "crypto_specialists": "1-2 FTE",
                "developers": "3-5 FTE",
                "security_architects": "1 FTE",
                "project_managers": "1 FTE",
            },
            "tools": [
                "Post-quantum cryptography libraries",
                "Hybrid crypto implementations",
                "Testing and validation tools",
                "Performance monitoring",
            ],
            "training": [
                "Post-quantum cryptography fundamentals",
                "NIST PQC standards training",
                "Crypto-agility best practices",
                "Implementation security",
            ],
        }

        return plan

    def _add_months(self, months: int) -> str:
        """Add months to current date"""
        import datetime

        current_date = datetime.datetime.now()

        # Simple month addition (approximate)
        year = current_date.year
        month = current_date.month + months

        while month > 12:
            month -= 12
            year += 1

        return f"{year}-{month:02d}-{current_date.day:02d}"

    def simulate_quantum_threat_progression(self) -> Dict:
        """Simulate quantum threat progression over time"""
        if not QISKIT_AVAILABLE:
            return {
                "simulation_available": False,
                "message": "Qiskit not available for quantum simulation",
            }

        # Simulate quantum computing progress
        years = list(range(2024, 2035))
        threat_levels = []

        for year in years:
            # Simple exponential model for quantum computing progress
            years_from_now = year - 2024

            # Simulate logical qubit count growth
            logical_qubits = 50 * (1.5**years_from_now)  # Doubling every ~2 years

            # Calculate threat level based on algorithm requirements
            rsa_2048_threat = (
                logical_qubits / 4000
            )  # ~4000 logical qubits needed for RSA-2048
            ecc_256_threat = (
                logical_qubits / 2000
            )  # ~2000 logical qubits needed for ECC-256

            threat_level = min(max(rsa_2048_threat, ecc_256_threat), 1.0)
            threat_levels.append(
                {
                    "year": year,
                    "logical_qubits": int(logical_qubits),
                    "threat_level": threat_level,
                    "rsa_2048_risk": min(rsa_2048_threat, 1.0),
                    "ecc_256_risk": min(ecc_256_threat, 1.0),
                }
            )

        return {
            "simulation_available": True,
            "threat_progression": threat_levels,
            "critical_years": {
                "rsa_2048": next(
                    (t["year"] for t in threat_levels if t["rsa_2048_risk"] >= 0.5),
                    2035,
                ),
                "ecc_256": next(
                    (t["year"] for t in threat_levels if t["ecc_256_risk"] >= 0.5), 2035
                ),
            },
        }

    def generate_comprehensive_report(
        self, directory: str, output_format: str = "text"
    ) -> str:
        """Generate comprehensive post-quantum migration report"""
        print(" Scanning directory for cryptographic usage...")
        scan_results = self.scan_directory(directory)

        print(" Generating migration plan...")
        migration_plan = self.generate_migration_plan(scan_results)

        print("[ANALYZE] Simulating quantum threat progression...")
        threat_simulation = self.simulate_quantum_threat_progression()

        if output_format == "json":
            report_data = {
                "scan_results": scan_results,
                "migration_plan": migration_plan,
                "threat_simulation": threat_simulation,
                "generated_at": time.strftime("%Y-%m-%d %H:%M:%S"),
            }
            return json.dumps(report_data, indent=2)

        # Text format
        report = []
        report.append(" Post-Quantum Cryptography Migration Assessment")
        report.append("=" * 60)
        report.append(f"[DATE] Assessment Date: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"[DIRECTORY] Directory: {directory}")
        report.append("")

        # Scan results summary
        report.append(" CRYPTOGRAPHIC INVENTORY")
        report.append("-" * 40)
        report.append(f"Files scanned: {scan_results['files_scanned']}")
        report.append(f"Files with crypto: {scan_results['vulnerable_files']}")
        report.append(f"Total vulnerabilities: {scan_results['total_vulnerabilities']}")
        report.append(f"Risk level: {migration_plan['assessment']['risk_level']}")
        report.append("")

        # Algorithm breakdown
        if scan_results.get("summary", {}).get("by_algorithm"):
            report.append(" Algorithm Usage:")
            for alg, count in sorted(
                scan_results["summary"]["by_algorithm"].items(),
                key=lambda x: x[1],
                reverse=True,
            ):
                report.append(f"   {alg}: {count} instances")
            report.append("")

        # Category breakdown
        if scan_results.get("summary", {}).get("by_category"):
            report.append(" By Category:")
            for cat, count in scan_results["summary"]["by_category"].items():
                report.append(f"   {cat.replace('_', ' ').title()}: {count} instances")
            report.append("")

        # Migration plan
        report.append("[ROADMAP]  MIGRATION PLAN")
        report.append("-" * 40)

        for phase_key, phase_info in migration_plan["phases"].items():
            report.append(f" {phase_info['title']} ({phase_info['duration']})")
            report.append(f"   Priority: {phase_info['priority']}")
            for task in phase_info["tasks"]:
                report.append(f"    -  {task}")
            report.append("")

        # Timeline
        timeline = migration_plan["timeline"]
        report.append("[DATE] TIMELINE")
        report.append("-" * 20)
        report.append(f"Start: {timeline['start_date']}")
        report.append(f"Phase 1 Complete: {timeline['phase_1_end']}")
        report.append(f"Phase 2 Complete: {timeline['phase_2_end']}")
        report.append(f"Phase 3 Complete: {timeline['phase_3_end']}")
        report.append(f"Full Migration: {timeline['full_migration']}")
        report.append("")

        # Threat simulation
        if threat_simulation["simulation_available"]:
            report.append("[ANALYZE] QUANTUM THREAT SIMULATION")
            report.append("-" * 40)

            critical_years = threat_simulation["critical_years"]
            report.append(f"RSA-2048 at risk: ~{critical_years['rsa_2048']}")
            report.append(f"ECC-256 at risk: ~{critical_years['ecc_256']}")
            report.append("")

            report.append("[STATS] Threat Progression (selected years):")
            progression = threat_simulation["threat_progression"]
            for i in range(0, len(progression), 2):  # Every other year
                year_data = progression[i]
                report.append(
                    f"   {year_data['year']}: {year_data['threat_level']:.1%} threat level "
                    f"({year_data['logical_qubits']} logical qubits)"
                )
            report.append("")

        # Recommendations
        report.append(" PRIORITY RECOMMENDATIONS")
        report.append("-" * 40)

        recommendations = migration_plan["recommendations"]
        for i, rec in enumerate(recommendations[:5], 1):  # Top 5
            report.append(f"{i}. {rec['action']}")
            report.append(f"   Finding: {rec['finding']}")
            report.append(f"   Priority: {rec['priority']}")
            report.append("")

        # NIST approved algorithms
        report.append("[STRUCTURE]  NIST-APPROVED POST-QUANTUM ALGORITHMS")
        report.append("-" * 50)

        for category, algorithms in self.nist_approved_algorithms.items():
            report.append(f" {category.title()}:")
            for alg_name, alg_info in algorithms.items():
                report.append(f"   [ITEM] {alg_name}")
                report.append(f"      Status: {alg_info['status']}")
                report.append(f"      Security Levels: {alg_info['security_levels']}")
                report.append(f"      Performance: {alg_info['performance']}")
            report.append("")

        # Most vulnerable files
        if scan_results["files"]:
            report.append("  MOST VULNERABLE FILES")
            report.append("-" * 30)

            # Sort files by vulnerability count
            sorted_files = sorted(
                scan_results["files"].items(),
                key=lambda x: x[1]["total_matches"],
                reverse=True,
            )

            for file_path, file_data in sorted_files[:10]:  # Top 10
                report.append(f"[FILE] {file_path}")
                report.append(f"   Vulnerabilities: {file_data['total_matches']}")

                # Show top algorithms
                top_algs = sorted(
                    file_data["vulnerable_algorithms"],
                    key=lambda x: x["matches"],
                    reverse=True,
                )[:3]
                for alg in top_algs:
                    report.append(
                        f"    -  {alg['algorithm']}: {alg['matches']} instances"
                    )
                report.append("")

        return "\n".join(report)


def main():
    """Main function for post-quantum migration tools"""
    parser = argparse.ArgumentParser(
        description="Post-Quantum Cryptography Migration Assessment Tools",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python pq_migration_tools.py /path/to/project
  python pq_migration_tools.py . --output migration_plan.txt
  python pq_migration_tools.py /src --format json --output report.json
  python pq_migration_tools.py /app --extensions .py .java .cpp
        """,
    )

    parser.add_argument("directory", help="Directory to scan for cryptographic usage")
    parser.add_argument(
        "--extensions",
        nargs="+",
        help="File extensions to scan (default: common code/config files)",
    )
    parser.add_argument("--output", "-o", help="Save report to file")
    parser.add_argument(
        "--format",
        choices=["text", "json"],
        default="text",
        help="Output format (default: text)",
    )
    parser.add_argument("--file-only", help="Scan single file instead of directory")

    args = parser.parse_args()

    # Initialize migration tools
    pq_tools = PostQuantumMigrationTools()

    print(" Houdinis - Post-Quantum Migration Tools")
    print("=" * 60)

    if args.file_only:
        print(f"[FILE] Scanning file: {args.file_only}")
        print()

        # Scan single file
        result = pq_tools.scan_file_for_crypto(args.file_only)

        if args.format == "json":
            output = json.dumps(result, indent=2)
        else:
            output = f"File: {result['file_path']}\n"
            output += f"Vulnerabilities: {len(result['vulnerable_algorithms'])}\n"
            output += f"Total matches: {result['total_matches']}\n\n"

            for vuln in result["vulnerable_algorithms"]:
                output += f"Algorithm: {vuln['algorithm']}\n"
                output += f"Category: {vuln['category']}\n"
                output += f"Matches: {vuln['matches']}\n"
                output += f"Examples: {', '.join(vuln['examples'])}\n\n"
    else:
        print(f"[DIRECTORY] Scanning directory: {args.directory}")
        print()

        # Comprehensive assessment
        output = pq_tools.generate_comprehensive_report(args.directory, args.format)

    # Display results
    print(output)

    # Save to file if requested
    if args.output:
        try:
            with open(args.output, "w") as f:
                f.write(output)
            print(f"\n[SAVE] Report saved to: {args.output}")
        except Exception as e:
            print(f"\n Error saving report: {e}")


if __name__ == "__main__":
    main()
