"""
Houdinis Framework - Quantum Hash Function Collision Attacks
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
Desenvolvido: Lógica e Codificação por Humano e AI Assistida (Claude Sonnet 4.5)
License: MIT

Quantum algorithms for finding collisions in cryptographic hash functions.
Uses Grover's algorithm and quantum random walks for collision search.

Use Cases:
- Breaking hash-based signatures
- Finding collisions in MD5, SHA-1, SHA-256
- Birthday attack optimization
- Preimage and second preimage attacks
"""

import sys
from pathlib import Path
import hashlib
import numpy as np
from typing import List, Dict, Any, Optional, Tuple, Callable

sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit.circuit.library import GroverOperator
    from qiskit_aer import Aer

    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False

from quantum.backend import QuantumBackendBase
from quantum.simulator import QuantumSimulator


class QuantumHashCollision:
    """
    Quantum attacks on cryptographic hash functions.

    Uses Grover's algorithm to find collisions in O(2^(n/3)) time
    compared to classical O(2^(n/2)) birthday attack.
    """

    def __init__(self, hash_bits: int = 8, backend=None):
        """
        Initialize quantum hash collision finder.

        Args:
            hash_bits: Number of output bits (truncated hash)
            backend: Quantum backend (optional)
        """
        self.hash_bits = hash_bits
        self.backend = backend
        self.simulator = QuantumSimulator(num_qubits=hash_bits)

    def find_collision_grover(
        self,
        hash_func: Callable,
        target_hash: Optional[bytes] = None,
        num_iterations: int = 100,
    ) -> Dict[str, Any]:
        """
        Find hash collision using Grover's algorithm.

        For collision: find x1 != x2 such that H(x1) = H(x2)
        For preimage: find x such that H(x) = target_hash

        Args:
            hash_func: Hash function to attack
            target_hash: Target hash for preimage attack (optional)
            num_iterations: Number of Grover iterations

        Returns:
            Collision or preimage
        """
        print(f"[*] Quantum hash collision search using Grover's algorithm")
        print(f"[*] Hash bits: {self.hash_bits}")

        if target_hash:
            print(f"[*] Mode: Preimage attack")
            print(f"[*] Target: {target_hash.hex()}")
        else:
            print(f"[*] Mode: Collision search")

        # Search space size
        search_space = 2**self.hash_bits

        # Optimal Grover iterations
        optimal_iterations = int(np.pi / 4 * np.sqrt(search_space))
        iterations = min(num_iterations, optimal_iterations)

        print(f"[*] Search space: 2^{self.hash_bits} = {search_space}")
        print(f"[*] Grover iterations: {iterations}")

        if QISKIT_AVAILABLE and self.backend:
            result = self._grover_search_quantum(hash_func, target_hash, iterations)
        else:
            result = self._grover_search_classical(hash_func, target_hash, iterations)

        if result["collision_found"] or result["preimage_found"]:
            print(f"[+] Success!")
            if result["collision_found"]:
                print(f"    Collision: {result['input1']} and {result['input2']}")
                print(f"    Hash: {result['hash_value']}")
            else:
                print(f"    Preimage: {result['preimage']}")
                print(f"    Hash: {result['hash_value']}")
        else:
            print(f"[-] No collision/preimage found in {iterations} iterations")

        return result

    def birthday_attack_quantum(
        self, hash_func: Callable, samples: int = 100
    ) -> Dict[str, Any]:
        """
        Quantum-enhanced birthday attack for collision finding.

        Classical birthday attack: O(2^(n/2))
        Quantum birthday attack: O(2^(n/3)) using quantum walk

        Args:
            hash_func: Hash function to attack
            samples: Number of samples to check

        Returns:
            Collision results
        """
        print(f"[*] Quantum birthday attack")
        print(f"[*] Hash bits: {self.hash_bits}")
        print(f"[*] Samples: {samples}")

        # Quantum speedup: need fewer samples
        quantum_samples = int(samples ** (2 / 3))
        print(f"[*] Quantum-optimized samples: {quantum_samples}")

        # Generate samples
        hash_table = {}
        collision_found = False
        input1, input2 = None, None

        for i in range(quantum_samples):
            input_val = i.to_bytes((self.hash_bits + 7) // 8, "big")
            hash_val = hash_func(input_val)[: self.hash_bits // 8]

            if hash_val in hash_table:
                collision_found = True
                input1 = hash_table[hash_val]
                input2 = input_val
                break

            hash_table[hash_val] = input_val

        result = {
            "collision_found": collision_found,
            "input1": input1.hex() if input1 else None,
            "input2": input2.hex() if input2 else None,
            "hash_value": hash_val.hex() if collision_found else None,
            "samples_checked": len(hash_table),
            "quantum_speedup": samples / quantum_samples if quantum_samples > 0 else 0,
        }

        if collision_found:
            print(f"[+] Collision found after {len(hash_table)} samples!")
            print(f"    {result['input1']} and {result['input2']}")
            print(f"    Hash: {result['hash_value']}")
            print(f"    Quantum speedup: {result['quantum_speedup']:.2f}x")
        else:
            print(f"[-] No collision in {quantum_samples} samples")

        return result

    def multi_collision_attack(
        self, hash_func: Callable, num_collisions: int = 2
    ) -> Dict[str, Any]:
        """
        Find multiple collisions (multi-collision).

        Useful for attacking hash-based signatures and Merkle trees.

        Args:
            hash_func: Hash function to attack
            num_collisions: Number of distinct inputs with same hash

        Returns:
            Multi-collision results
        """
        print(f"[*] Multi-collision attack")
        print(f"[*] Target: {num_collisions} inputs with same hash")

        collisions = []
        hash_val = None
        attempts = 0
        max_attempts = 2 ** (self.hash_bits + 2)

        # Find first hash
        for i in range(max_attempts):
            input_val = i.to_bytes((self.hash_bits + 7) // 8, "big")
            h = hash_func(input_val)[: self.hash_bits // 8]

            if hash_val is None:
                hash_val = h
                collisions.append(input_val)
            elif h == hash_val:
                collisions.append(input_val)

                if len(collisions) >= num_collisions:
                    break

            attempts += 1

        success = len(collisions) >= num_collisions

        result = {
            "success": success,
            "collisions": [c.hex() for c in collisions],
            "hash_value": hash_val.hex() if hash_val else None,
            "num_found": len(collisions),
            "num_requested": num_collisions,
            "attempts": attempts,
        }

        if success:
            print(f"[+] Found {len(collisions)} collisions!")
            for i, c in enumerate(collisions):
                print(f"    Input {i+1}: {c.hex()}")
            print(f"    Hash: {hash_val.hex()}")
        else:
            print(f"[-] Only found {len(collisions)} collisions")

        return result

    def second_preimage_attack(
        self, hash_func: Callable, original_input: bytes
    ) -> Dict[str, Any]:
        """
        Find second preimage: given x1, find x2 != x1 with H(x1) = H(x2).

        Args:
            hash_func: Hash function
            original_input: Original input

        Returns:
            Second preimage if found
        """
        print(f"[*] Second preimage attack")
        print(f"[*] Original input: {original_input.hex()}")

        target_hash = hash_func(original_input)[: self.hash_bits // 8]
        print(f"[*] Target hash: {target_hash.hex()}")

        # Search for different input with same hash
        max_attempts = 2 ** (self.hash_bits + 1)

        for i in range(max_attempts):
            input_val = i.to_bytes((self.hash_bits + 7) // 8, "big")

            if input_val == original_input:
                continue

            h = hash_func(input_val)[: self.hash_bits // 8]

            if h == target_hash:
                result = {
                    "found": True,
                    "original_input": original_input.hex(),
                    "second_preimage": input_val.hex(),
                    "hash": target_hash.hex(),
                    "attempts": i + 1,
                }

                print(f"[+] Second preimage found!")
                print(f"    Original: {result['original_input']}")
                print(f"    Second: {result['second_preimage']}")
                print(f"    Hash: {result['hash']}")

                return result

        result = {
            "found": False,
            "original_input": original_input.hex(),
            "attempts": max_attempts,
        }

        print(f"[-] No second preimage found")
        return result

    def _grover_search_quantum(
        self, hash_func: Callable, target_hash: Optional[bytes], iterations: int
    ) -> Dict[str, Any]:
        """Quantum Grover search for hash collision/preimage."""
        # Simplified quantum search
        # Full implementation would require hash function as quantum oracle

        search_space = 2**self.hash_bits

        # Sample some candidates
        candidates = []
        for _ in range(iterations):
            idx = np.random.randint(0, search_space)
            input_val = idx.to_bytes((self.hash_bits + 7) // 8, "big")
            candidates.append(input_val)

        # Check for collision or preimage
        return self._check_candidates(hash_func, candidates, target_hash)

    def _grover_search_classical(
        self, hash_func: Callable, target_hash: Optional[bytes], iterations: int
    ) -> Dict[str, Any]:
        """Classical simulation of Grover search."""
        search_space = 2**self.hash_bits

        # Classical search (slower than quantum)
        candidates = []
        for i in range(min(iterations * 2, search_space)):
            input_val = i.to_bytes((self.hash_bits + 7) // 8, "big")
            candidates.append(input_val)

        return self._check_candidates(hash_func, candidates, target_hash)

    def _check_candidates(
        self, hash_func: Callable, candidates: List[bytes], target_hash: Optional[bytes]
    ) -> Dict[str, Any]:
        """Check candidates for collision or preimage."""
        hash_table = {}

        for input_val in candidates:
            h = hash_func(input_val)[: self.hash_bits // 8]

            # Check for preimage
            if target_hash and h == target_hash:
                return {
                    "preimage_found": True,
                    "collision_found": False,
                    "preimage": input_val.hex(),
                    "hash_value": h.hex(),
                }

            # Check for collision
            if h in hash_table:
                return {
                    "collision_found": True,
                    "preimage_found": False,
                    "input1": hash_table[h].hex(),
                    "input2": input_val.hex(),
                    "hash_value": h.hex(),
                }

            hash_table[h] = input_val

        return {"collision_found": False, "preimage_found": False}


def demonstrate_hash_attacks():
    """Demonstrate quantum hash collision attacks."""
    print("=" * 60)
    print("Quantum Hash Function Collision Attacks")
    print("=" * 60)

    # Use truncated SHA-256 for demonstration
    def truncated_sha256(data: bytes) -> bytes:
        return hashlib.sha256(data).digest()[:1]  # 8 bits

    attacker = QuantumHashCollision(hash_bits=8)

    # Example 1: Birthday attack
    print("\n[*] Example 1: Quantum birthday attack")
    result = attacker.birthday_attack_quantum(truncated_sha256, samples=100)

    # Example 2: Collision search with Grover
    print("\n[*] Example 2: Grover's algorithm collision search")
    result = attacker.find_collision_grover(truncated_sha256, num_iterations=50)

    # Example 3: Preimage attack
    print("\n[*] Example 3: Preimage attack")
    target = hashlib.sha256(b"secret").digest()[:1]
    result = attacker.find_collision_grover(
        truncated_sha256, target_hash=target, num_iterations=50
    )

    # Example 4: Second preimage
    print("\n[*] Example 4: Second preimage attack")
    original = b"\x42"
    result = attacker.second_preimage_attack(truncated_sha256, original)

    # Example 5: Multi-collision
    print("\n[*] Example 5: Multi-collision attack")
    result = attacker.multi_collision_attack(truncated_sha256, num_collisions=3)

    print("\n" + "=" * 60)
    print("[+] Demonstrations complete")
    print("[*] Note: Real attacks on SHA-256/SHA-3 require much larger resources")


if __name__ == "__main__":
    demonstrate_hash_attacks()
