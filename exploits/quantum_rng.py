#!/usr/bin/env python3
"""
Houdinis Framework - Quantum Random Number Generator
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
Desenvolvido: Lógica e Codificação por Humano e AI Assistida (Claude Sonnet 4.5)
License: MIT

Implements quantum random number generation for cryptographic applications
and tests quantum entropy sources.
"""

import sys
import os

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit import transpile
    import numpy as np

    QUANTUM_AVAILABLE = True
except ImportError:
    QUANTUM_AVAILABLE = False
    print("  Quantum libraries not available, using classical PRNG")

import random
import hashlib
import time
import struct
from typing import Dict, List, Optional
import secrets


class QuantumRNG:
    """Quantum Random Number Generator implementation"""

    def __init__(self) -> None:
        self.name = "Quantum Random Number Generator"
        self.description = (
            "Generate cryptographically secure random numbers using quantum mechanics"
        )
        self.author = "Mauro Risonho de Paula Assumpção aka firebitsbr"
        self.difficulty = "Advanced"
        self.category = "quantum_cryptography"
        self.entropy_buffer = []

    def info(self) -> Dict:
        """Return QRNG information"""
        return {
            "name": self.name,
            "description": self.description,
            "author": self.author,
            "difficulty": self.difficulty,
            "category": self.category,
            "purpose": "Generate true random numbers for cryptographic applications",
            "quantum_advantage": "True randomness from quantum superposition collapse",
            "requirements": ["quantum_backend"],
        }

    def quantum_coin_flip(
        self, num_bits: int, backend_type: str = "simulator"
    ) -> Optional[str]:
        """Generate random bits using quantum coin flips"""
        if not QUANTUM_AVAILABLE:
            print(" Quantum libraries not available")
            return None

        try:
            from quantum.backend import QuantumBackendManager

            backend_manager = QuantumBackendManager()

            backend = backend_manager.get_backend()
            if not backend:
                print(" No quantum backend available")
                return None

            # Limit to reasonable number of qubits for simulation
            max_qubits = min(num_bits, 20)

            # Create quantum circuit
            qreg = QuantumRegister(max_qubits, "q")
            creg = ClassicalRegister(max_qubits, "c")
            qc = QuantumCircuit(qreg, creg)

            # Apply Hadamard gates for superposition (coin flip)
            qc.h(qreg)

            # Measure all qubits
            qc.measure(qreg, creg)

            print(f"[RANDOM] Generating {max_qubits} quantum random bits...")

            # Execute circuit
            transpiled = transpile(qc, backend)
            job = backend.run(transpiled, shots=1)
            result = job.result()
            counts = result.get_counts()

            # Extract random bits from measurement
            if counts:
                # Get the most frequent result (should be random)
                random_bitstring = max(counts, key=counts.get)

                # If we need more bits than we generated, repeat the process
                if num_bits > max_qubits:
                    remaining_bits = num_bits - max_qubits
                    additional_bits = self.quantum_coin_flip(
                        remaining_bits, backend_type
                    )
                    if additional_bits:
                        random_bitstring += additional_bits

                return random_bitstring[:num_bits]
            else:
                return None

        except Exception as e:
            print(f" Quantum RNG error: {e}")
            return None

    def classical_fallback_rng(self, num_bits: int) -> str:
        """Classical cryptographically secure random number generator fallback"""
        print(f"[LOADING] Using classical CSPRNG fallback for {num_bits} bits")

        # Use system entropy source
        random_bytes = secrets.randbits(num_bits)
        return format(random_bytes, f"0{num_bits}b")

    def test_randomness_quality(self, bit_sequence: str) -> Dict:
        """Test the quality of random bit sequence"""
        if not bit_sequence:
            return {"error": "No bit sequence provided"}

        n = len(bit_sequence)
        ones = bit_sequence.count("1")
        zeros = bit_sequence.count("0")

        analysis = {
            "sequence_length": n,
            "ones_count": ones,
            "zeros_count": zeros,
            "balance_ratio": ones / n if n > 0 else 0,
            "tests": {},
        }

        # Frequency test (monobit test)
        frequency_score = abs(0.5 - analysis["balance_ratio"])
        analysis["tests"]["frequency"] = {
            "score": frequency_score,
            "pass": frequency_score < 0.1,
            "description": "Tests if ratio of 1s and 0s is approximately 1:1",
        }

        # Runs test
        runs = 1
        for i in range(1, n):
            if bit_sequence[i] != bit_sequence[i - 1]:
                runs += 1

        expected_runs = (2 * ones * zeros / n) + 1 if n > 0 else 0
        runs_score = (
            abs(runs - expected_runs) / expected_runs if expected_runs > 0 else 1
        )

        analysis["tests"]["runs"] = {
            "observed_runs": runs,
            "expected_runs": expected_runs,
            "score": runs_score,
            "pass": runs_score < 0.3,
            "description": "Tests for clustering of bits",
        }

        # Serial correlation test (simplified)
        if n > 1:
            matches = sum(
                1 for i in range(n - 1) if bit_sequence[i] == bit_sequence[i + 1]
            )
            correlation_score = abs(matches - n / 4) / (n / 4) if n > 0 else 1

            analysis["tests"]["serial_correlation"] = {
                "matches": matches,
                "score": correlation_score,
                "pass": correlation_score < 0.3,
                "description": "Tests for correlation between consecutive bits",
            }

        # Overall quality assessment
        passed_tests = sum(
            1 for test in analysis["tests"].values() if test.get("pass", False)
        )
        total_tests = len(analysis["tests"])

        analysis["overall_quality"] = {
            "passed_tests": passed_tests,
            "total_tests": total_tests,
            "pass_rate": passed_tests / total_tests if total_tests > 0 else 0,
            "quality_grade": (
                "EXCELLENT"
                if passed_tests == total_tests
                else (
                    "GOOD"
                    if passed_tests >= total_tests * 0.8
                    else "FAIR" if passed_tests >= total_tests * 0.6 else "POOR"
                )
            ),
        }

        return analysis

    def extract_entropy(self, bit_sequence: str) -> float:
        """Calculate Shannon entropy of bit sequence"""
        if not bit_sequence:
            return 0.0

        # Count occurrences of each bit value
        ones = bit_sequence.count("1")
        zeros = bit_sequence.count("0")
        total = len(bit_sequence)

        if total == 0:
            return 0.0

        # Calculate probabilities
        p_zero = zeros / total if total > 0 else 0
        p_one = ones / total if total > 0 else 0

        # Calculate Shannon entropy
        entropy = 0.0
        if p_zero > 0:
            entropy -= p_zero * np.log2(p_zero)
        if p_one > 0:
            entropy -= p_one * np.log2(p_one)

        return entropy

    def generate_random_bytes(self, num_bytes: int, use_quantum: bool = True) -> bytes:
        """Generate random bytes using quantum or classical methods"""
        num_bits = num_bytes * 8

        print(f"[RANDOM] Generating {num_bytes} random bytes ({num_bits} bits)")

        if use_quantum and QUANTUM_AVAILABLE:
            bit_sequence = self.quantum_coin_flip(num_bits)
            if bit_sequence:
                print(" Using quantum random number generation")
            else:
                print("  Quantum RNG failed, falling back to classical")
                bit_sequence = self.classical_fallback_rng(num_bits)
        else:
            bit_sequence = self.classical_fallback_rng(num_bits)

        # Convert bit string to bytes
        random_bytes = bytearray()
        for i in range(0, len(bit_sequence), 8):
            byte_bits = bit_sequence[i : i + 8]
            if len(byte_bits) == 8:
                byte_value = int(byte_bits, 2)
                random_bytes.append(byte_value)

        return bytes(random_bytes)

    def benchmark_rng_performance(self, num_samples: int = 1000) -> Dict:
        """Benchmark RNG performance"""
        print(f"[RUNNING] Benchmarking RNG performance with {num_samples} samples...")

        benchmark_results = {
            "classical": {"time": 0, "entropy": 0, "quality": {}},
            "quantum": {"time": 0, "entropy": 0, "quality": {}},
        }

        # Benchmark classical RNG
        start_time = time.time()
        classical_bits = self.classical_fallback_rng(num_samples)
        classical_time = time.time() - start_time

        classical_entropy = self.extract_entropy(classical_bits)
        classical_quality = self.test_randomness_quality(classical_bits)

        benchmark_results["classical"] = {
            "time": classical_time,
            "entropy": classical_entropy,
            "quality": classical_quality,
            "bits_per_second": (
                num_samples / classical_time if classical_time > 0 else 0
            ),
        }

        print(
            f" Classical RNG: {classical_time:.4f}s, entropy: {classical_entropy:.4f}"
        )

        # Benchmark quantum RNG (if available)
        if QUANTUM_AVAILABLE:
            start_time = time.time()
            quantum_bits = self.quantum_coin_flip(
                min(num_samples, 100)
            )  # Limit for simulation
            quantum_time = time.time() - start_time

            if quantum_bits:
                quantum_entropy = self.extract_entropy(quantum_bits)
                quantum_quality = self.test_randomness_quality(quantum_bits)

                benchmark_results["quantum"] = {
                    "time": quantum_time,
                    "entropy": quantum_entropy,
                    "quality": quantum_quality,
                    "bits_per_second": (
                        len(quantum_bits) / quantum_time if quantum_time > 0 else 0
                    ),
                }

                print(
                    f" Quantum RNG: {quantum_time:.4f}s, entropy: {quantum_entropy:.4f}"
                )
            else:
                benchmark_results["quantum"] = {"error": "Quantum RNG failed"}
        else:
            benchmark_results["quantum"] = {"error": "Quantum libraries not available"}

        return benchmark_results

    def generate_cryptographic_key(self, key_size: int, key_type: str = "AES") -> Dict:
        """Generate cryptographic key using quantum RNG"""
        print(f" Generating {key_size}-bit {key_type} key using quantum RNG")

        # Generate random key material
        key_bytes = self.generate_random_bytes(key_size // 8, use_quantum=True)

        # Test key quality
        key_bits = "".join(format(b, "08b") for b in key_bytes)
        quality_analysis = self.test_randomness_quality(key_bits)
        entropy = self.extract_entropy(key_bits)

        key_info = {
            "key_type": key_type,
            "key_size_bits": key_size,
            "key_size_bytes": len(key_bytes),
            "key_hex": key_bytes.hex(),
            "key_base64": __import__("base64").b64encode(key_bytes).decode(),
            "entropy": entropy,
            "quality_analysis": quality_analysis,
            "generation_method": "quantum" if QUANTUM_AVAILABLE else "classical",
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        }

        print(f" Generated {key_size}-bit key")
        print(f"   Entropy: {entropy:.4f} bits per bit")
        print(f"   Quality: {quality_analysis['overall_quality']['quality_grade']}")

        return key_info

    def run(self, operation: str, **kwargs) -> Dict:
        """Run quantum RNG operations"""
        try:
            print(f"[RANDOM] Quantum Random Number Generator")
            print(f"=" * 50)

            if operation == "generate_bits":
                num_bits = kwargs.get("num_bits", 32)
                use_quantum = kwargs.get("use_quantum", True)

                if use_quantum and QUANTUM_AVAILABLE:
                    bits = self.quantum_coin_flip(num_bits)
                    method = "quantum"
                else:
                    bits = self.classical_fallback_rng(num_bits)
                    method = "classical"

                if bits:
                    quality = self.test_randomness_quality(bits)
                    entropy = self.extract_entropy(bits)

                    return {
                        "success": True,
                        "operation": "generate_bits",
                        "bits": bits,
                        "num_bits": len(bits),
                        "method": method,
                        "entropy": entropy,
                        "quality": quality,
                    }
                else:
                    return {"success": False, "error": "Failed to generate random bits"}

            elif operation == "generate_key":
                key_size = kwargs.get("key_size", 256)
                key_type = kwargs.get("key_type", "AES")

                key_info = self.generate_cryptographic_key(key_size, key_type)

                return {
                    "success": True,
                    "operation": "generate_key",
                    "key_info": key_info,
                }

            elif operation == "benchmark":
                num_samples = kwargs.get("num_samples", 1000)
                benchmark_results = self.benchmark_rng_performance(num_samples)

                return {
                    "success": True,
                    "operation": "benchmark",
                    "benchmark_results": benchmark_results,
                }

            else:
                return {"success": False, "error": f"Unknown operation: {operation}"}

        except Exception as e:
            error_msg = f"QRNG operation error: {e}"
            print(f" {error_msg}")
            return {"success": False, "error": error_msg}


def main():
    """CLI interface for Quantum RNG"""
    if len(sys.argv) < 2:
        print("Usage: python quantum_rng.py <operation> [options]")
        print("Operations:")
        print("  bits <num_bits> - Generate random bits")
        print("  key <key_size> [key_type] - Generate cryptographic key")
        print("  benchmark [num_samples] - Benchmark RNG performance")
        print("Examples:")
        print("  python quantum_rng.py bits 64")
        print("  python quantum_rng.py key 256 AES")
        print("  python quantum_rng.py benchmark 1000")
        sys.exit(1)

    operation = sys.argv[1]
    qrng = QuantumRNG()

    if operation == "bits":
        num_bits = int(sys.argv[2]) if len(sys.argv) > 2 else 32
        result = qrng.run("generate_bits", num_bits=num_bits)

        if result["success"]:
            print(f"\n[TARGET] Generated {result['num_bits']} random bits:")
            print(f"Bits: {result['bits']}")
            print(f"Method: {result['method']}")
            print(f"Entropy: {result['entropy']:.4f}")
            print(f"Quality: {result['quality']['overall_quality']['quality_grade']}")

    elif operation == "key":
        key_size = int(sys.argv[2]) if len(sys.argv) > 2 else 256
        key_type = sys.argv[3] if len(sys.argv) > 3 else "AES"
        result = qrng.run("generate_key", key_size=key_size, key_type=key_type)

        if result["success"]:
            key_info = result["key_info"]
            print(f"\n Generated {key_size}-bit {key_type} key:")
            print(f"Hex: {key_info['key_hex']}")
            print(f"Base64: {key_info['key_base64']}")
            print(f"Entropy: {key_info['entropy']:.4f}")
            print(
                f"Quality: {key_info['quality_analysis']['overall_quality']['quality_grade']}"
            )

    elif operation == "benchmark":
        num_samples = int(sys.argv[2]) if len(sys.argv) > 2 else 1000
        result = qrng.run("benchmark", num_samples=num_samples)

        if result["success"]:
            benchmark = result["benchmark_results"]
            print(f"\n RNG Benchmark Results:")

            if "classical" in benchmark:
                classical = benchmark["classical"]
                print(f"Classical RNG:")
                print(f"  Time: {classical['time']:.4f}s")
                print(f"  Entropy: {classical['entropy']:.4f}")
                print(f"  Speed: {classical['bits_per_second']:.0f} bits/sec")

            if "quantum" in benchmark and "error" not in benchmark["quantum"]:
                quantum = benchmark["quantum"]
                print(f"Quantum RNG:")
                print(f"  Time: {quantum['time']:.4f}s")
                print(f"  Entropy: {quantum['entropy']:.4f}")
                print(f"  Speed: {quantum['bits_per_second']:.0f} bits/sec")
    else:
        print(f" Unknown operation: {operation}")
        sys.exit(1)

    if result["success"]:
        print(f"\n[TARGET] Operation completed successfully!")
        sys.exit(0)
    else:
        print(f"\n Operation failed: {result.get('error', 'Unknown error')}")
        sys.exit(1)


if __name__ == "__main__":
    main()
