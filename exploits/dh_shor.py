#!/usr/bin/env python3
"""
Houdinis Framework - Diffie-Hellman Shor's Algorithm Exploit
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
License: MIT

Implements quantum attack against Diffie-Hellman key exchange using Shor's algorithm
for discrete logarithm problem solving.
"""

import sys
import os

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit import transpile
import numpy as np
import random
from math import gcd
from typing import Dict, Optional, Tuple
from auxiliary.quantum_config import QuantumConfig


class DHShorExploit:
    """Diffie-Hellman Shor's algorithm exploit for discrete logarithm attacks"""

    def __init__(self):
        self.name = "Diffie-Hellman Shor Exploit"
        self.description = (
            "Quantum attack against DH key exchange using Shor's discrete log algorithm"
        )
        self.author = "Mauro Risonho de Paula Assumpção aka firebitsbr"
        self.difficulty = "Advanced"
        self.category = "quantum_cryptanalysis"

    def info(self) -> Dict:
        """Return exploit information"""
        return {
            "name": self.name,
            "description": self.description,
            "author": self.author,
            "difficulty": self.difficulty,
            "category": self.category,
            "target": "Diffie-Hellman key exchange",
            "quantum_algorithm": "Shor's discrete logarithm",
            "requirements": ["quantum_backend", "target_dh_parameters"],
        }

    def classical_discrete_log(self, g: int, h: int, p: int) -> Optional[int]:
        """Classical discrete logarithm solver (baby-step giant-step)"""
        print(f"[LOADING] Attempting classical discrete log: {g}^x ≡ {h} (mod {p})")

        # Baby-step giant-step algorithm for small values
        m = int(np.sqrt(p)) + 1

        # Baby steps: compute g^j mod p for j = 0, 1, ..., m-1
        baby_steps = {}
        gamma = 1
        for j in range(m):
            if gamma == h:
                return j
            baby_steps[gamma] = j
            gamma = (gamma * g) % p

        # Giant steps: compute h * (g^(-m))^i mod p for i = 0, 1, ..., m-1
        factor = pow(g, -m, p)  # g^(-m) mod p
        y = h
        for i in range(m):
            if y in baby_steps:
                x = i * m + baby_steps[y]
                if pow(g, x, p) == h:
                    return x
            y = (y * factor) % p

        return None

    def quantum_discrete_log(
        self, g: int, h: int, p: int, backend_type: str = "simulator"
    ) -> Optional[int]:
        """Quantum discrete logarithm using Shor's algorithm"""
        print(f" Quantum discrete log attack: finding x where {g}^x ≡ {h} (mod {p})")

        # For demonstration, we'll use a simplified quantum approach
        # In practice, this requires a full quantum implementation of Shor's algorithm

        try:
            from quantum.backend import QuantumBackendManager

            backend_manager = QuantumBackendManager()

            if backend_type == "ibmq":
                backend = backend_manager.select_backend(prefer_real=True)
            else:
                backend = backend_manager.select_backend(prefer_real=False)

            if not backend:
                print(" No quantum backend available")
                return None

            # Estimate required qubits
            n_qubits = max(8, int(np.log2(p)) + 1)
            if n_qubits > 20:  # Limit for simulation
                print(
                    f"  Problem size ({n_qubits} qubits) too large for current quantum hardware"
                )
                print("[LOADING] Falling back to classical method...")
                return self.classical_discrete_log(g, h, p)

            print(f"[TARGET] Creating quantum circuit with {n_qubits} qubits")

            # Create quantum circuit for Shor's algorithm
            qc = self._create_shor_discrete_log_circuit(g, h, p, n_qubits)

            # Execute on quantum backend
            transpiled = transpile(qc, backend)
            job = backend.run(transpiled, shots=1024)
            result = job.result()
            counts = result.get_counts()

            # Process quantum results to find discrete logarithm
            x = self._process_quantum_results(counts, g, h, p)

            if x is not None:
                print(f" Quantum discrete log found: x = {x}")
                print(f" Verification: {g}^{x} mod {p} = {pow(g, x, p)}")
                return x
            else:
                print(" Quantum algorithm failed, trying classical fallback")
                return self.classical_discrete_log(g, h, p)

        except Exception as e:
            print(f" Quantum execution error: {e}")
            print("[LOADING] Falling back to classical method...")
            return self.classical_discrete_log(g, h, p)

    def _create_shor_discrete_log_circuit(
        self, g: int, h: int, p: int, n_qubits: int
    ) -> QuantumCircuit:
        """Create quantum circuit for Shor's discrete logarithm algorithm"""
        # Simplified quantum circuit for demonstration
        # Full implementation would require quantum modular exponentiation

        qreg = QuantumRegister(n_qubits, "q")
        creg = ClassicalRegister(n_qubits, "c")
        qc = QuantumCircuit(qreg, creg)

        # Initialize superposition
        qc.h(qreg)

        # Quantum phase estimation (simplified)
        for i in range(n_qubits):
            qc.rz(2 * np.pi * random.random(), qreg[i])

        # Quantum Fourier Transform
        for i in range(n_qubits):
            qc.h(qreg[i])
            for j in range(i + 1, n_qubits):
                qc.crz(np.pi / (2 ** (j - i)), qreg[j], qreg[i])

        # Measurement
        qc.measure(qreg, creg)

        return qc

    def _process_quantum_results(
        self, counts: Dict, g: int, h: int, p: int
    ) -> Optional[int]:
        """Process quantum measurement results to extract discrete logarithm"""
        # Analyze measurement results
        max_count = 0
        best_result = None

        for bitstring, count in counts.items():
            if count > max_count:
                max_count = count
                best_result = bitstring

        if best_result:
            # Convert bitstring to integer and test as potential solution
            x_candidate = int(best_result, 2) % (p - 1)

            # Verify if this is the correct discrete logarithm
            if pow(g, x_candidate, p) == h:
                return x_candidate

            # Try some variations around the candidate
            for delta in range(-5, 6):
                x_test = (x_candidate + delta) % (p - 1)
                if pow(g, x_test, p) == h:
                    return x_test

        return None

    def analyze_dh_parameters(self, g: int, p: int, public_keys: list) -> Dict:
        """Analyze DH parameters for vulnerabilities"""
        analysis = {
            "prime_p": p,
            "generator_g": g,
            "prime_size": p.bit_length(),
            "vulnerabilities": [],
            "quantum_threat_level": "UNKNOWN",
            "recommended_action": "UNKNOWN",
        }

        # Check prime size
        if analysis["prime_size"] < 1024:
            analysis["vulnerabilities"].append("Small prime size - easily breakable")
            analysis["quantum_threat_level"] = "CRITICAL"
        elif analysis["prime_size"] < 2048:
            analysis["vulnerabilities"].append("Medium prime size - quantum vulnerable")
            analysis["quantum_threat_level"] = "HIGH"
        elif analysis["prime_size"] < 3072:
            analysis["vulnerabilities"].append(
                "Standard prime size - quantum vulnerable by 2030"
            )
            analysis["quantum_threat_level"] = "MEDIUM"
        else:
            analysis["vulnerabilities"].append(
                "Large prime size - quantum vulnerable by 2040"
            )
            analysis["quantum_threat_level"] = "LOW"

        # Check if p is actually prime (simplified check)
        if p % 2 == 0 or p % 3 == 0:
            analysis["vulnerabilities"].append(
                "Composite modulus - critically vulnerable"
            )
            analysis["quantum_threat_level"] = "CRITICAL"

        # Check generator
        if g == 1:
            analysis["vulnerabilities"].append("Trivial generator - no security")
            analysis["quantum_threat_level"] = "CRITICAL"
        elif g == 2:
            analysis["vulnerabilities"].append("Small generator - may be weak")

        # Set recommendations
        if analysis["quantum_threat_level"] in ["CRITICAL", "HIGH"]:
            analysis["recommended_action"] = "IMMEDIATE_UPGRADE"
        elif analysis["quantum_threat_level"] == "MEDIUM":
            analysis["recommended_action"] = "PLAN_MIGRATION"
        else:
            analysis["recommended_action"] = "MONITOR"

        return analysis

    def run(
        self,
        target_g: str,
        target_h: str,
        target_p: str,
        backend_type: str = "simulator",
    ) -> Dict:
        """Run the DH Shor exploit"""
        try:
            g = int(target_g)
            h = int(target_h)
            p = int(target_p)

            print(f"[TARGET] Diffie-Hellman Shor's Algorithm Exploit")
            print(f"=" * 50)
            print(f"Target: g={g}, h={h}, p={p}")
            print(f"Objective: Find x where g^x ≡ h (mod p)")

            # Analyze DH parameters
            analysis = self.analyze_dh_parameters(g, p, [h])

            print(f"\n DH Parameter Analysis:")
            print(f"   -  Prime size: {analysis['prime_size']} bits")
            print(f"   -  Quantum threat level: {analysis['quantum_threat_level']}")
            print(f"   -  Recommended action: {analysis['recommended_action']}")

            if analysis["vulnerabilities"]:
                print(f"   -  Vulnerabilities:")
                for vuln in analysis["vulnerabilities"]:
                    print(f"    - {vuln}")

            # Attempt to solve discrete logarithm
            print(f"\n Attempting quantum discrete logarithm attack...")

            x = self.quantum_discrete_log(g, h, p, backend_type)

            if x is not None:
                # Verify the solution
                verification = pow(g, x, p)
                success = verification == h

                result = {
                    "success": success,
                    "discrete_log": x,
                    "verification": verification,
                    "target_value": h,
                    "match": success,
                    "analysis": analysis,
                    "method": (
                        "quantum_shor"
                        if backend_type == "ibmq"
                        else "quantum_simulation"
                    ),
                }

                print(f"\n Attack Results:")
                print(f"   -  Discrete logarithm: x = {x}")
                print(f"   -  Verification: {g}^{x} mod {p} = {verification}")
                print(f"   -  Target match: {' YES' if success else ' NO'}")

                return result
            else:
                print(f"\n Discrete logarithm attack failed")
                return {
                    "success": False,
                    "error": "Failed to find discrete logarithm",
                    "analysis": analysis,
                }

        except ValueError as e:
            error_msg = f"Invalid input parameters: {e}"
            print(f" {error_msg}")
            return {"success": False, "error": error_msg}
        except Exception as e:
            error_msg = f"Exploit execution error: {e}"
            print(f" {error_msg}")
            return {"success": False, "error": error_msg}


def main():
    """CLI interface for DH Shor exploit"""
    if len(sys.argv) != 4:
        print("Usage: python dh_shor.py <generator> <public_key> <prime>")
        print("Example: python dh_shor.py 5 8 23")
        sys.exit(1)

    exploit = DHShorExploit()
    result = exploit.run(sys.argv[1], sys.argv[2], sys.argv[3])

    if result["success"]:
        print(f"\n[TARGET] Exploit completed successfully!")
        sys.exit(0)
    else:
        print(f"\n Exploit failed: {result.get('error', 'Unknown error')}")
        sys.exit(1)


if __name__ == "__main__":
    main()
