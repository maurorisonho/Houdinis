#!/usr/bin/env python3
"""
Houdinis Framework - TLS Store Now Decrypt Later Exploit
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
License: MIT

Implements harvest now decrypt later attack against TLS sessions,
capturing encrypted traffic for future quantum decryption.
"""

import sys
import os

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import socket
import ssl
import struct
import datetime
import json
import sqlite3
from typing import Dict, List, Optional, Tuple
import threading
import time
import base64


class TLSStoreNowDecryptLaterExploit:
    """Store Now Decrypt Later attack against TLS connections"""

    def __init__(self) -> None:
        self.name = "TLS Store Now Decrypt Later"
        self.description = "Capture TLS traffic for future quantum decryption"
        self.author = "Mauro Risonho de Paula Assumpção aka firebitsbr"
        self.difficulty = "Advanced"
        self.category = "harvest_attack"
        self.captured_sessions = []
        self.db_path = "tls_harvest.db"

    def info(self) -> Dict:
        """Return exploit information"""
        return {
            "name": self.name,
            "description": self.description,
            "author": self.author,
            "difficulty": self.difficulty,
            "category": self.category,
            "target": "TLS/SSL encrypted connections",
            "quantum_threat": "Future quantum computers will break current TLS crypto",
            "requirements": ["network_access", "packet_capture_capability"],
        }

    def init_database(self) -> None:
        """Initialize SQLite database for storing captured sessions"""
        try:
            # Secure database initialization with proper permissions
            import os
            import stat

            # Ensure database directory exists with secure permissions
            db_dir = os.path.dirname(self.db_path)
            if not os.path.exists(db_dir):
                os.makedirs(db_dir, mode=0o700)  # Only owner can access

            # Connect with secure settings
            conn = sqlite3.connect(self.db_path, timeout=10.0)

            # Enable foreign key constraints and secure settings
            conn.execute("PRAGMA foreign_keys = ON")
            conn.execute("PRAGMA journal_mode = WAL")  # Better concurrency
            conn.execute("PRAGMA synchronous = FULL")  # Data integrity

            cursor = conn.cursor()

            # Create table with proper constraints
            cursor.execute(
                """
                CREATE TABLE IF NOT EXISTS tls_sessions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT NOT NULL,
                    source_ip TEXT NOT NULL CHECK(length(source_ip) <= 45),
                    dest_ip TEXT NOT NULL CHECK(length(dest_ip) <= 45),
                    source_port INTEGER NOT NULL CHECK(source_port > 0 AND source_port <= 65535),
                    dest_port INTEGER NOT NULL CHECK(dest_port > 0 AND dest_port <= 65535),
                    tls_version TEXT CHECK(length(tls_version) <= 10),
                    cipher_suite TEXT CHECK(length(cipher_suite) <= 100),
                    key_exchange TEXT CHECK(length(key_exchange) <= 50),
                    encryption_algorithm TEXT CHECK(length(encryption_algorithm) <= 50),
                    key_size INTEGER CHECK(key_size >= 0 AND key_size <= 8192),
                    handshake_data BLOB,
                    encrypted_data BLOB,
                    data_size INTEGER CHECK(data_size >= 0),
                    quantum_vulnerable INTEGER CHECK(quantum_vulnerable IN (0, 1)),
                    risk_score REAL CHECK(risk_score >= 0.0 AND risk_score <= 10.0),
                    notes TEXT CHECK(length(notes) <= 1000),
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            """
            )

            # Create index for performance
            cursor.execute(
                """
                CREATE INDEX IF NOT EXISTS idx_tls_sessions_timestamp 
                ON tls_sessions(timestamp)
            """
            )

            conn.commit()
            conn.close()

            # Set secure file permissions on database
            os.chmod(self.db_path, 0o600)  # Only owner can read/write

            print(f"[FILE] Database initialized securely: {self.db_path}")

        except sqlite3.Error as e:
            print(f"[!] Database initialization error: {e}")
            raise
        except Exception as e:
            print(f"[!] Unexpected error during database setup: {e}")
            raise

    def analyze_tls_vulnerability(
        self, cipher_suite: str, key_size: int
    ) -> Tuple[bool, float, str]:
        """Analyze TLS session vulnerability to quantum attacks"""

        # Quantum vulnerable algorithms
        vulnerable_kex = ["RSA", "DHE", "ECDHE"]
        vulnerable_ciphers = ["AES-128", "AES-256", "3DES", "ChaCha20"]

        is_vulnerable = False
        risk_score = 0.0
        threat_timeline = "Unknown"

        # Analyze key exchange
        for kex in vulnerable_kex:
            if kex in cipher_suite.upper():
                is_vulnerable = True
                if kex == "RSA":
                    if key_size <= 1024:
                        risk_score = 9.5
                        threat_timeline = "2025-2027"
                    elif key_size <= 2048:
                        risk_score = 8.5
                        threat_timeline = "2030-2035"
                    elif key_size <= 4096:
                        risk_score = 7.0
                        threat_timeline = "2035-2040"
                elif "ECDHE" in kex:
                    if key_size <= 256:
                        risk_score = 8.0
                        threat_timeline = "2030-2035"
                    elif key_size <= 384:
                        risk_score = 6.5
                        threat_timeline = "2035-2040"
                break

        # Analyze symmetric encryption (Grover's algorithm impact)
        for cipher in vulnerable_ciphers:
            if cipher in cipher_suite.upper():
                if "AES-128" in cipher:
                    risk_score = max(
                        risk_score, 6.0
                    )  # Reduced to 64-bit effective security
                elif "AES-256" in cipher:
                    risk_score = max(
                        risk_score, 4.0
                    )  # Reduced to 128-bit effective security
                break

        return is_vulnerable, risk_score, threat_timeline

    def capture_tls_handshake(
        self, target_host: str, target_port: int
    ) -> Optional[Dict]:
        """Capture TLS handshake and analyze vulnerability"""
        try:
            print(f"[TARGET] Capturing TLS handshake from {target_host}:{target_port}")

            # Create socket connection
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)

            # Connect to target
            sock.connect((target_host, target_port))

            # Wrap with SSL to get handshake information
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            ssl_sock = context.wrap_socket(sock, server_hostname=target_host)

            # Extract TLS information
            tls_info = {
                "timestamp": datetime.datetime.now().isoformat(),
                "source_ip": sock.getsockname()[0],
                "dest_ip": target_host,
                "source_port": sock.getsockname()[1],
                "dest_port": target_port,
                "tls_version": ssl_sock.version(),
                "cipher_suite": (
                    ssl_sock.cipher()[0] if ssl_sock.cipher() else "Unknown"
                ),
                "key_exchange": "Unknown",
                "encryption_algorithm": (
                    ssl_sock.cipher()[1] if ssl_sock.cipher() else "Unknown"
                ),
                "key_size": ssl_sock.cipher()[2] if ssl_sock.cipher() else 0,
                "certificate": ssl_sock.getpeercert(),
                "handshake_data": b"",  # In real implementation, capture actual handshake
                "encrypted_data": b"",  # Placeholder for captured traffic
                "data_size": 0,
            }

            # Analyze vulnerability
            is_vulnerable, risk_score, threat_timeline = self.analyze_tls_vulnerability(
                tls_info["cipher_suite"], tls_info["key_size"]
            )

            tls_info["quantum_vulnerable"] = is_vulnerable
            tls_info["risk_score"] = risk_score
            tls_info["threat_timeline"] = threat_timeline

            # Simulate capturing some encrypted data
            try:
                # Send a simple HTTP request to capture encrypted traffic
                request = (
                    b"GET / HTTP/1.1\\r\\nHost: "
                    + target_host.encode()
                    + b"\\r\\n\\r\\n"
                )
                ssl_sock.send(request)

                # Receive response (encrypted)
                response = ssl_sock.recv(4096)
                tls_info["encrypted_data"] = base64.b64encode(response).decode()
                tls_info["data_size"] = len(response)

            except Exception as e:
                print(f"  Could not capture encrypted data: {e}")

            ssl_sock.close()
            sock.close()

            print(f" TLS session captured successfully")
            print(f"   -  TLS Version: {tls_info['tls_version']}")
            print(f"   -  Cipher Suite: {tls_info['cipher_suite']}")
            print(f"   -  Key Size: {tls_info['key_size']} bits")
            print(f"   -  Quantum Vulnerable: {'Yes' if is_vulnerable else 'No'}")
            print(f"   -  Risk Score: {risk_score}/10")
            print(f"   -  Threat Timeline: {threat_timeline}")

            return tls_info

        except Exception as e:
            print(f" Failed to capture TLS session: {e}")
            return None

    def store_session(self, session_data: Dict) -> None:
        """Store captured TLS session in database"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            cursor.execute(
                """
                INSERT INTO tls_sessions (
                    timestamp, source_ip, dest_ip, source_port, dest_port,
                    tls_version, cipher_suite, key_exchange, encryption_algorithm,
                    key_size, handshake_data, encrypted_data, data_size,
                    quantum_vulnerable, risk_score, notes
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
                (
                    session_data["timestamp"],
                    session_data["source_ip"],
                    session_data["dest_ip"],
                    session_data["source_port"],
                    session_data["dest_port"],
                    session_data["tls_version"],
                    session_data["cipher_suite"],
                    session_data.get("key_exchange", "Unknown"),
                    session_data["encryption_algorithm"],
                    session_data["key_size"],
                    session_data.get("handshake_data", b""),
                    (
                        session_data.get("encrypted_data", "").encode()
                        if isinstance(session_data.get("encrypted_data", ""), str)
                        else session_data.get("encrypted_data", b"")
                    ),
                    session_data["data_size"],
                    1 if session_data.get("quantum_vulnerable", False) else 0,
                    session_data.get("risk_score", 0.0),
                    f"Threat timeline: {session_data.get('threat_timeline', 'Unknown')}",
                ),
            )

            conn.commit()
            conn.close()

            print(f"[SAVE] Session stored in database")

        except Exception as e:
            print(f" Failed to store session: {e}")

    def analyze_harvest(self) -> Dict:
        """Analyze the collected TLS sessions"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            # Get all sessions
            cursor.execute("SELECT * FROM tls_sessions")
            sessions = cursor.fetchall()

            # Analyze collected data
            analysis = {
                "total_sessions": len(sessions),
                "vulnerable_sessions": 0,
                "total_data_size": 0,
                "cipher_suites": {},
                "risk_distribution": {"low": 0, "medium": 0, "high": 0, "critical": 0},
                "threat_timelines": {},
                "avg_risk_score": 0.0,
            }

            total_risk = 0.0

            for session in sessions:
                # Extract fields (adjust indices based on table structure)
                quantum_vulnerable = session[14]  # quantum_vulnerable column
                risk_score = session[15]  # risk_score column
                data_size = session[13]  # data_size column
                cipher_suite = session[7]  # cipher_suite column

                if quantum_vulnerable:
                    analysis["vulnerable_sessions"] += 1

                analysis["total_data_size"] += data_size
                total_risk += risk_score

                # Cipher suite distribution
                if cipher_suite not in analysis["cipher_suites"]:
                    analysis["cipher_suites"][cipher_suite] = 0
                analysis["cipher_suites"][cipher_suite] += 1

                # Risk distribution
                if risk_score < 3.0:
                    analysis["risk_distribution"]["low"] += 1
                elif risk_score < 6.0:
                    analysis["risk_distribution"]["medium"] += 1
                elif risk_score < 8.0:
                    analysis["risk_distribution"]["high"] += 1
                else:
                    analysis["risk_distribution"]["critical"] += 1

            if len(sessions) > 0:
                analysis["avg_risk_score"] = total_risk / len(sessions)

            conn.close()
            return analysis

        except Exception as e:
            print(f" Failed to analyze harvest: {e}")
            return {}

    def generate_report(self) -> str:
        """Generate detailed harvest report"""
        analysis = self.analyze_harvest()

        if not analysis:
            return "No analysis data available"

        report = f"""
[SATELLITE]  TLS HARVEST NOW DECRYPT LATER - ANALYSIS REPORT
================================================================

 COLLECTION SUMMARY:
   -  Total TLS sessions captured: {analysis['total_sessions']}
   -  Quantum-vulnerable sessions: {analysis['vulnerable_sessions']}
   -  Total encrypted data collected: {analysis['total_data_size']} bytes
   -  Average risk score: {analysis['avg_risk_score']:.2f}/10

 CIPHER SUITE DISTRIBUTION:
"""

        for cipher, count in analysis["cipher_suites"].items():
            percentage = (
                (count / analysis["total_sessions"]) * 100
                if analysis["total_sessions"] > 0
                else 0
            )
            report += f"   -  {cipher}: {count} sessions ({percentage:.1f}%)\n"

        report += f"""
  RISK ASSESSMENT:
   -  Critical risk (8-10): {analysis['risk_distribution']['critical']} sessions
   -  High risk (6-8): {analysis['risk_distribution']['high']} sessions  
   -  Medium risk (3-6): {analysis['risk_distribution']['medium']} sessions
   -  Low risk (0-3): {analysis['risk_distribution']['low']} sessions

[TARGET] RECOMMENDATIONS:
   -  Migrate {analysis['vulnerable_sessions']} vulnerable sessions to post-quantum crypto
   -  Prioritize critical and high-risk sessions for immediate upgrade
   -  Implement crypto-agility for rapid algorithm updates
   -  Monitor quantum computing developments for threat timeline updates

⏰ QUANTUM THREAT TIMELINE:
   -  2025-2027: RSA-1024 and weak ECC vulnerable
   -  2030-2035: RSA-2048 and standard ECC vulnerable  
   -  2035-2040: RSA-4096 and strong ECC vulnerable
   -  2040+: All classical crypto assumed broken

[ALERT] LEGAL NOTICE:
This data collection is for authorized security testing only.
Ensure compliance with applicable laws and regulations.
"""

        return report

    def run(self, target_hosts: List[str], target_ports: List[int] = None) -> Dict:
        """Run the TLS Store Now Decrypt Later exploit"""
        try:
            if target_ports is None:
                target_ports = [443]  # Default HTTPS port

            print(f"[SATELLITE]  TLS Store Now Decrypt Later Exploit")
            print(f"=" * 50)
            print(f"Targets: {', '.join(target_hosts)}")
            print(f"Ports: {', '.join(map(str, target_ports))}")

            # Initialize database
            self.init_database()

            captured_count = 0

            # Capture TLS sessions from each target
            for host in target_hosts:
                for port in target_ports:
                    print(f"\n[TARGET] Targeting {host}:{port}")

                    session_data = self.capture_tls_handshake(host, port)

                    if session_data:
                        self.store_session(session_data)
                        captured_count += 1
                        time.sleep(1)  # Rate limiting

            # Generate analysis
            analysis = self.analyze_harvest()
            report = self.generate_report()

            print(f"\n Harvest Complete!")
            print(f"   -  Sessions captured: {captured_count}")
            print(
                f"   -  Vulnerable sessions: {analysis.get('vulnerable_sessions', 0)}"
            )
            print(f"   -  Database: {self.db_path}")

            return {
                "success": True,
                "sessions_captured": captured_count,
                "vulnerable_sessions": analysis.get("vulnerable_sessions", 0),
                "analysis": analysis,
                "report": report,
                "database_path": self.db_path,
            }

        except Exception as e:
            error_msg = f"Exploit execution error: {e}"
            print(f" {error_msg}")
            return {"success": False, "error": error_msg}


def main():
    """CLI interface for TLS Store Now Decrypt Later exploit"""
    if len(sys.argv) < 2:
        print(
            "Usage: python tls_sndl.py <target_host1> [target_host2] ... [--port PORT]"
        )
        print("Example: python tls_sndl.py google.com facebook.com --port 443")
        sys.exit(1)

    target_hosts = []
    target_ports = [443]  # Default

    # Parse arguments
    i = 1
    while i < len(sys.argv):
        if sys.argv[i] == "--port":
            if i + 1 < len(sys.argv):
                target_ports = [int(sys.argv[i + 1])]
                i += 2
            else:
                print(" --port requires a port number")
                sys.exit(1)
        else:
            target_hosts.append(sys.argv[i])
            i += 1

    if not target_hosts:
        print(" No target hosts specified")
        sys.exit(1)

    exploit = TLSStoreNowDecryptLaterExploit()
    result = exploit.run(target_hosts, target_ports)

    if result["success"]:
        print(f"\n[TARGET] Exploit completed successfully!")
        print(f"Report saved to database: {result['database_path']}")

        # Print report
        print("\n" + result["report"])
        sys.exit(0)
    else:
        print(f"\n Exploit failed: {result.get('error', 'Unknown error')}")
        sys.exit(1)


if __name__ == "__main__":
    main()
