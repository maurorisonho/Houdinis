#!/usr/bin/env python3
"""
IKE Quantum Attack Module
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
License: MIT

Specialized attacks against IKE (Internet Key Exchange) protocol vulnerabilities
"""

import sys
import socket
import struct
import binascii
import hashlib
import hmac
import argparse
import time
import json
from typing import Dict, List, Optional, Tuple, Any, Union

try:
    from qiskit import QuantumCircuit, transpile
    from qiskit.providers.aer import AerSimulator
    import numpy as np

    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False

try:
    from scapy.all import IP, UDP, Raw, sr1, sr, conf
    from scapy.contrib.ikev2 import *

    SCAPY_AVAILABLE = True
except ImportError:
    SCAPY_AVAILABLE = False

try:
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import rsa, dh, ec
    from cryptography.hazmat.primitives.kdf.hkdf import HKDF

    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False


class IKEQuantumAttack:
    """IKE Protocol Quantum Attack Suite"""

    def __init__(self) -> None:
        self.ike_ports = [500, 4500]  # Standard IKE and NAT-T ports

        # IKE Transform constants
        self.transforms = {
            "ENCR_AES_CBC": 12,
            "ENCR_3DES": 3,
            "ENCR_AES_GCM_16": 20,
            "PRF_HMAC_SHA1": 2,
            "PRF_HMAC_SHA256": 5,
            "PRF_HMAC_SHA384": 6,
            "INTEG_HMAC_SHA1_96": 2,
            "INTEG_HMAC_SHA256_128": 12,
            "DH_GROUP_14": 14,  # MODP 2048-bit
            "DH_GROUP_19": 19,  # ECP 256-bit
            "DH_GROUP_20": 20,  # ECP 384-bit
            "DH_GROUP_21": 21,  # ECP 521-bit
        }

        self.vulnerability_db = {
            "weak_dh_groups": {
                1: {"name": "MODP 768", "vulnerable": True, "severity": "CRITICAL"},
                2: {"name": "MODP 1024", "vulnerable": True, "severity": "HIGH"},
                5: {"name": "MODP 1536", "vulnerable": True, "severity": "HIGH"},
                14: {"name": "MODP 2048", "vulnerable": True, "severity": "MEDIUM"},
                15: {"name": "MODP 3072", "vulnerable": True, "severity": "MEDIUM"},
                16: {"name": "MODP 4096", "vulnerable": True, "severity": "LOW"},
                19: {"name": "ECP 256", "vulnerable": True, "severity": "MEDIUM"},
                20: {"name": "ECP 384", "vulnerable": True, "severity": "LOW"},
                21: {"name": "ECP 521", "vulnerable": True, "severity": "LOW"},
            },
            "weak_encryption": {
                "DES": {"quantum_security": 28, "vulnerable": True},
                "3DES": {"quantum_security": 56, "vulnerable": True},
                "AES-128": {"quantum_security": 64, "vulnerable": True},
                "AES-192": {"quantum_security": 96, "vulnerable": False},
                "AES-256": {"quantum_security": 128, "vulnerable": False},
            },
            "weak_hashes": {
                "MD5": {"collision_resistance": 64, "vulnerable": True},
                "SHA-1": {"collision_resistance": 80, "vulnerable": True},
                "SHA-256": {"collision_resistance": 128, "vulnerable": False},
                "SHA-384": {"collision_resistance": 192, "vulnerable": False},
            },
        }

    def craft_ike_sa_init(
        self, destination_ip: str, destination_port: int = 500
    ) -> bytes:
        """Craft IKE SA_INIT request packet"""
        # IKE Header (28 bytes)
        initiator_spi = b"\x01\x02\x03\x04\x05\x06\x07\x08"
        responder_spi = b"\x00" * 8
        next_payload = 0x21  # SA payload
        version = 0x20  # IKEv2
        exchange_type = 0x22  # IKE_SA_INIT
        flags = 0x08  # Initiator flag
        message_id = 0
        length = 0  # Will be calculated

        # SA Payload
        sa_payload = self._create_sa_payload()

        # Key Exchange Payload
        ke_payload = self._create_ke_payload()

        # Nonce Payload
        nonce_payload = self._create_nonce_payload()

        # Calculate total length
        header = struct.pack(
            "!8s8sBBBBII",
            initiator_spi,
            responder_spi,
            next_payload,
            version,
            exchange_type,
            flags,
            message_id,
            0,
        )

        packet = header + sa_payload + ke_payload + nonce_payload

        # Update length field
        packet = packet[:24] + struct.pack("!I", len(packet)) + packet[28:]

        return packet

    def _create_sa_payload(self) -> bytes:
        """Create SA payload with proposals"""
        # Simplified SA payload
        next_payload = 0x22  # KE payload next
        critical = 0
        length = 44  # Fixed for this example

        # Proposal: IKE SA
        proposal_num = 1
        protocol_id = 1  # IKE
        spi_size = 0
        num_transforms = 4

        transforms = [
            (1, 12, 256),  # ENCR_AES_CBC with 256-bit key
            (2, 5, 0),  # PRF_HMAC_SHA256
            (3, 12, 0),  # INTEG_HMAC_SHA256_128
            (4, 14, 0),  # DH_GROUP_14 (MODP 2048)
        ]

        payload = struct.pack("!BBH", next_payload, critical, length)
        payload += struct.pack(
            "!BBBB", proposal_num, protocol_id, spi_size, num_transforms
        )

        for transform_type, transform_id, attribute in transforms:
            transform_length = 8 if attribute == 0 else 12
            payload += struct.pack(
                "!BBHBBH",
                3 if transform != transforms[-1] else 0,
                0,
                transform_length,
                transform_type,
                0,
                transform_id,
            )
            if attribute > 0:
                payload += struct.pack("!HH", 0x800E, attribute)

        return payload

    def _create_ke_payload(self) -> bytes:
        """Create Key Exchange payload"""
        next_payload = 0x28  # Nonce payload next
        critical = 0
        length = 264  # 4 (header) + 4 (dh group) + 256 (key data)
        dh_group = 14  # MODP 2048

        # Generate fake DH public key (256 bytes for MODP 2048)
        key_data = b"\x02" + b"\x00" * 255  # Simplified

        payload = struct.pack("!BBHHH", next_payload, critical, length, dh_group, 0)
        payload += key_data

        return payload

    def _create_nonce_payload(self) -> bytes:
        """Create Nonce payload"""
        next_payload = 0  # Last payload
        critical = 0
        nonce_data = b"\x01\x02\x03\x04" * 8  # 32-byte nonce
        length = 4 + len(nonce_data)

        payload = struct.pack("!BBH", next_payload, critical, length)
        payload += nonce_data

        return payload

    def send_ike_probe(self, target: str, port: int = 500, timeout: int = 5) -> Dict:
        """Send IKE probe and analyze response"""
        result = {
            "target": target,
            "port": port,
            "ike_detected": False,
            "version": None,
            "vulnerabilities": [],
            "supported_transforms": {},
            "error": None,
        }

        try:
            if SCAPY_AVAILABLE:
                # Use Scapy for better packet crafting
                packet = self._craft_scapy_ike_probe(target, port)
                response = sr1(packet, timeout=timeout, verbose=0)

                if response:
                    result["ike_detected"] = True
                    result.update(self._analyze_ike_response(response))
            else:
                # Fallback to raw socket
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.settimeout(timeout)

                probe_packet = self.craft_ike_sa_init(target, port)
                sock.sendto(probe_packet, (target, port))

                try:
                    response, addr = sock.recvfrom(4096)
                    result["ike_detected"] = True
                    result.update(self._analyze_raw_response(response))
                except socket.timeout:
                    result["error"] = "No response - IKE service may not be available"

                sock.close()

        except Exception as e:
            result["error"] = str(e)

        return result

    def _craft_scapy_ike_probe(self, target: str, port: int) -> Any:
        """Craft IKE probe using Scapy"""
        if not SCAPY_AVAILABLE:
            return None

        # Create IKEv2 SA_INIT packet
        packet = (
            IP(dst=target)
            / UDP(dport=port)
            / Raw(load=self.craft_ike_sa_init(target, port))
        )
        return packet

    def _analyze_ike_response(self, response: Union[bytes, 'IP', None]) -> Dict:  # type: ignore[name-defined]
        """Analyze IKE response packet (Scapy)"""
        analysis = {
            "version": "Unknown",
            "exchange_type": "Unknown",
            "supported_transforms": {},
            "vulnerabilities": [],
        }

        if hasattr(response, "load"):
            raw_data = bytes(response.load)
            analysis.update(self._analyze_raw_response(raw_data))

        return analysis

    def _analyze_raw_response(self, data: bytes) -> Dict:
        """Analyze raw IKE response data"""
        analysis = {
            "version": "Unknown",
            "exchange_type": "Unknown",
            "supported_transforms": {},
            "vulnerabilities": [],
        }

        if len(data) < 28:
            return analysis

        try:
            # Parse IKE header
            (
                ispi,
                rspi,
                next_payload,
                version,
                exchange_type,
                flags,
                message_id,
                length,
            ) = struct.unpack("!8s8sBBBBII", data[:28])

            if version & 0xF0 == 0x20:
                analysis["version"] = "IKEv2"
            elif version & 0xF0 == 0x10:
                analysis["version"] = "IKEv1"

            analysis["exchange_type"] = f"0x{exchange_type:02x}"

            # Parse payloads
            payload_data = data[28:]
            transforms = self._parse_ike_payloads(payload_data)
            analysis["supported_transforms"] = transforms

            # Analyze for vulnerabilities
            analysis["vulnerabilities"] = self._assess_ike_vulnerabilities(transforms)

        except Exception as e:
            analysis["parse_error"] = str(e)

        return analysis

    def _parse_ike_payloads(self, payload_data: bytes) -> Dict:
        """Parse IKE payloads to extract supported transforms"""
        transforms = {"encryption": [], "prf": [], "integrity": [], "dh_groups": []}

        offset = 0
        while offset < len(payload_data) - 4:
            try:
                next_payload, critical, length = struct.unpack(
                    "!BBH", payload_data[offset : offset + 4]
                )

                if length < 4 or offset + length > len(payload_data):
                    break

                payload_content = payload_data[offset + 4 : offset + length]

                # Parse SA payload (simplified)
                if next_payload == 0x21:  # SA payload
                    # This would contain more complex parsing in a real implementation
                    pass

                offset += length

            except struct.error:
                break

        return transforms

    def _assess_ike_vulnerabilities(self, transforms: Dict) -> List[str]:
        """Assess IKE configuration for quantum vulnerabilities"""
        vulnerabilities = []

        # Check DH groups
        for dh_group in transforms.get("dh_groups", []):
            if dh_group in self.vulnerability_db["weak_dh_groups"]:
                group_info = self.vulnerability_db["weak_dh_groups"][dh_group]
                if group_info["vulnerable"]:
                    vulnerabilities.append(
                        f"Weak DH group {dh_group} ({group_info['name']}) - "
                        f"Severity: {group_info['severity']}"
                    )

        # Check encryption algorithms
        for encryption in transforms.get("encryption", []):
            if encryption in self.vulnerability_db["weak_encryption"]:
                enc_info = self.vulnerability_db["weak_encryption"][encryption]
                if enc_info["vulnerable"]:
                    vulnerabilities.append(
                        f"Weak encryption {encryption} - "
                        f"Quantum security: {enc_info['quantum_security']} bits"
                    )

        return vulnerabilities

    def simulate_quantum_ike_attack(
        self, dh_group: int, auth_method: str = "RSA"
    ) -> Dict:
        """Simulate quantum attack on IKE exchange"""
        if not QISKIT_AVAILABLE:
            return {
                "success": False,
                "method": "classical_estimation",
                "message": "Qiskit not available for quantum simulation",
            }

        print(f"[ANALYZE] Simulating quantum attack on IKE with DH group {dh_group}...")

        # Get DH group info
        group_info = self.vulnerability_db["weak_dh_groups"].get(dh_group, {})
        if not group_info:
            return {"success": False, "message": f"Unknown DH group {dh_group}"}

        # Estimate key size
        key_sizes = {
            1: 768,
            2: 1024,
            5: 1536,
            14: 2048,
            15: 3072,
            16: 4096,
            19: 256,
            20: 384,
            21: 521,
        }
        key_size = key_sizes.get(dh_group, 2048)

        # Create quantum circuit for attack simulation
        n_qubits = min(16, key_size // 64)  # Scaled for simulation
        qc = QuantumCircuit(n_qubits, n_qubits)

        # Phase 1: Superposition for period finding
        for i in range(n_qubits // 2):
            qc.h(i)

        # Phase 2: Modular exponentiation (simplified)
        for i in range(n_qubits // 2):
            qc.cx(i, n_qubits // 2 + (i % (n_qubits // 2)))

        # Phase 3: QFT for period extraction
        for i in range(n_qubits // 2):
            qc.h(i)
            for j in range(i):
                qc.cp(np.pi / (2 ** (i - j)), j, i)

        qc.measure_all()

        # Simulate attack
        simulator = AerSimulator()
        transpiled_qc = transpile(qc, simulator)
        job = simulator.run(transpiled_qc, shots=1024)
        result = job.result()
        counts = result.get_counts()

        # Calculate attack metrics
        most_common = max(counts.items(), key=lambda x: x[1])
        success_rate = most_common[1] / 1024

        # Estimate real-world requirements
        logical_qubits = key_size * 2
        physical_qubits = logical_qubits * 1000  # Error correction overhead

        return {
            "success": True,
            "method": "quantum_simulation",
            "target": f"DH Group {dh_group} ({group_info['name']})",
            "key_size": key_size,
            "logical_qubits_required": logical_qubits,
            "physical_qubits_required": physical_qubits,
            "success_rate": success_rate,
            "attack_time_estimate": f"{key_size//200} hours on fault-tolerant QC",
            "classical_equivalent": f"2^{key_size//2} operations",
            "vulnerability_level": group_info["severity"],
        }

    def perform_ike_security_audit(self, targets: List[str]) -> str:
        """Perform comprehensive IKE security audit"""
        report = []
        report.append(" IKE Quantum Security Audit")
        report.append("=" * 50)
        report.append(f"[DATE] Audit Date: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"[TARGET] Targets: {len(targets)}")
        report.append("")

        total_vulnerable = 0
        critical_vulnerabilities = []

        for i, target in enumerate(targets, 1):
            report.append(f"[TARGET] Target {i}: {target}")
            report.append("-" * 40)

            # Test both standard ports
            target_vulnerable = False
            target_vulnerabilities = []

            for port in self.ike_ports:
                probe_result = self.send_ike_probe(target, port)

                if probe_result["ike_detected"]:
                    report.append(f" IKE service detected on port {port}")
                    report.append(
                        f"   Version: {probe_result.get('version', 'Unknown')}"
                    )

                    vulnerabilities = probe_result.get("vulnerabilities", [])
                    if vulnerabilities:
                        target_vulnerable = True
                        target_vulnerabilities.extend(vulnerabilities)

                        report.append("  Vulnerabilities:")
                        for vuln in vulnerabilities:
                            report.append(f"       -  {vuln}")
                            if "CRITICAL" in vuln:
                                critical_vulnerabilities.append(
                                    f"{target}:{port} - {vuln}"
                                )
                else:
                    if probe_result.get("error"):
                        report.append(f" Port {port}: {probe_result['error']}")
                    else:
                        report.append(f" No IKE service on port {port}")

            if target_vulnerable:
                total_vulnerable += 1

            # Simulate quantum attacks on detected services
            if target_vulnerable:
                report.append("\n[ANALYZE] Quantum Attack Simulation:")

                # Test common vulnerable DH groups
                test_groups = [2, 14, 19]  # MODP 1024, MODP 2048, ECP 256

                for dh_group in test_groups:
                    attack_result = self.simulate_quantum_ike_attack(dh_group)

                    if attack_result["success"]:
                        report.append(f"   [TARGET] {attack_result['target']}")
                        report.append(
                            f"      Qubits needed: {attack_result['logical_qubits_required']}"
                        )
                        report.append(
                            f"      Attack time: {attack_result['attack_time_estimate']}"
                        )
                        report.append(
                            f"      Severity: {attack_result['vulnerability_level']}"
                        )

            report.append("")

        # Post-quantum recommendations
        report.append("  Post-Quantum IKE Recommendations")
        report.append("-" * 45)
        report.append(" Immediate Actions:")
        report.append("    -  Disable weak DH groups (1, 2, 5)")
        report.append("    -  Use DH groups ≥14 (MODP 2048+) as interim measure")
        report.append("    -  Implement certificate-based authentication")
        report.append("    -  Enable Perfect Forward Secrecy (PFS)")
        report.append("")

        report.append(" Medium-term Migration:")
        report.append("    -  Deploy hybrid classical+post-quantum KEMs")
        report.append("    -  Implement post-quantum signature schemes")
        report.append("    -  Use quantum-resistant symmetric algorithms (AES-256)")
        report.append("    -  Plan for full post-quantum migration")
        report.append("")

        report.append(" Long-term Strategy:")
        report.append("    -  Migrate to quantum key distribution (QKD)")
        report.append("    -  Implement post-quantum IKE standards")
        report.append("    -  Deploy quantum-resistant VPN protocols")
        report.append("    -  Regular quantum threat assessments")
        report.append("")

        # Summary
        report.append(" AUDIT SUMMARY")
        report.append("=" * 30)
        report.append(f"Targets scanned: {len(targets)}")
        report.append(f"Vulnerable targets: {total_vulnerable}")
        report.append(f"Critical vulnerabilities: {len(critical_vulnerabilities)}")

        if critical_vulnerabilities:
            report.append("\n[ALERT] CRITICAL ISSUES:")
            for crit_vuln in critical_vulnerabilities:
                report.append(f"    -  {crit_vuln}")

        report.append(
            f"\n  Overall Risk Level: {'HIGH' if critical_vulnerabilities else 'MEDIUM' if total_vulnerable else 'LOW'}"
        )

        return "\n".join(report)


def main():
    """Main function for IKE quantum attack module"""
    parser = argparse.ArgumentParser(
        description="IKE Quantum Attack and Security Assessment",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python ike_quantum_attack.py 192.168.1.1
  python ike_quantum_attack.py vpn.example.com --ports 500 4500
  python ike_quantum_attack.py --targets targets.txt
  python ike_quantum_attack.py host1 host2 host3 --output report.txt
        """,
    )

    parser.add_argument("targets", nargs="*", help="Target IP addresses or hostnames")
    parser.add_argument(
        "--targets-file", "-t", help="File containing target addresses (one per line)"
    )
    parser.add_argument(
        "--ports",
        nargs="+",
        type=int,
        default=[500, 4500],
        help="IKE ports to test (default: 500 4500)",
    )
    parser.add_argument(
        "--timeout", type=int, default=5, help="Probe timeout in seconds (default: 5)"
    )
    parser.add_argument("--output", "-o", help="Save report to file")
    parser.add_argument(
        "--simulate-only",
        action="store_true",
        help="Only run quantum attack simulations",
    )

    args = parser.parse_args()

    # Collect targets
    targets = list(args.targets) if args.targets else []

    if args.targets_file:
        try:
            with open(args.targets_file, "r") as f:
                file_targets = [line.strip() for line in f if line.strip()]
                targets.extend(file_targets)
        except Exception as e:
            print(f" Error reading targets file: {e}")
            sys.exit(1)

    if not targets and not args.simulate_only:
        print(" No targets specified")
        parser.print_help()
        sys.exit(1)

    # Initialize attack module
    ike_attack = IKEQuantumAttack()
    ike_attack.ike_ports = args.ports

    print(" Houdinis - IKE Quantum Attack Module")
    print("=" * 60)

    if args.simulate_only:
        print("[ANALYZE] Running quantum attack simulations only...")
        print()

        # Run simulations on common DH groups
        dh_groups = [1, 2, 5, 14, 19, 20]
        for dh_group in dh_groups:
            result = ike_attack.simulate_quantum_ike_attack(dh_group)
            if result["success"]:
                print(f"[TARGET] {result['target']}")
                print(f"   Logical qubits: {result['logical_qubits_required']}")
                print(f"   Attack time: {result['attack_time_estimate']}")
                print(f"   Severity: {result['vulnerability_level']}")
                print()
    else:
        print(f"[TARGET] Targets: {', '.join(targets)}")
        print()

        # Perform comprehensive audit
        report = ike_attack.perform_ike_security_audit(targets)

        # Display report
        print(report)

        # Save to file if requested
        if args.output:
            try:
                with open(args.output, "w") as f:
                    f.write(report)
                print(f"\n[SAVE] Report saved to: {args.output}")
            except Exception as e:
                print(f"\n Error saving report: {e}")


if __name__ == "__main__":
    main()
