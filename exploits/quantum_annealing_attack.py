"""
Houdinis Framework - Quantum Annealing Attack Implementation
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
Desenvolvido: Lógica e Codificação por Humano e AI Assistida (Claude Sonnet 4.5)
License: MIT

Quantum annealing for optimization-based cryptographic attacks.
Can be used to break optimization-based cryptosystems and find
optimal attack parameters.

Use Case: Breaking cryptographic schemes based on optimization problems
         (e.g., lattice-based crypto, knapsack problems).
"""

import sys
from pathlib import Path
import numpy as np
from typing import List, Dict, Any, Optional, Tuple, Callable

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit_aer import Aer

    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False
    print("[!] Qiskit not available. Using classical simulation.")

try:
    # Try to import D-Wave Ocean SDK for real quantum annealing
    from dwave.system import DWaveSampler, EmbeddingComposite
    import dimod

    DWAVE_AVAILABLE = True
except ImportError:
    DWAVE_AVAILABLE = False
    print("[!] D-Wave Ocean SDK not available. Using simulation.")

from quantum.backend import QuantumBackendBase
from quantum.simulator import QuantumSimulator


class QuantumAnnealingAttack:
    """
    Quantum annealing for cryptographic optimization attacks.

    Quantum annealing is particularly effective for:
    - Knapsack-based cryptosystems
    - Subset sum problems
    - Lattice reduction
    - Constraint satisfaction problems
    """

    def __init__(self, problem_size: int = 8, use_dwave: bool = False) -> None:
        """
        Initialize quantum annealing attack.

        Args:
            problem_size: Size of the optimization problem
            use_dwave: Whether to use D-Wave hardware (requires credentials)
        """
        self.problem_size = problem_size
        self.use_dwave = use_dwave and DWAVE_AVAILABLE
        self.simulator = QuantumSimulator(num_qubits=problem_size)

    def create_qubo_matrix(
        self, objective: Callable, constraints: Optional[List[Callable]] = None
    ) -> np.ndarray:
        """
        Create QUBO (Quadratic Unconstrained Binary Optimization) matrix.

        Args:
            objective: Objective function to minimize
            constraints: Optional list of constraint functions

        Returns:
            QUBO matrix
        """
        n = self.problem_size
        Q = np.zeros((n, n))

        # Construct QUBO from objective function
        # This is a simplified version - real QUBO construction is problem-specific
        for i in range(n):
            for j in range(i, n):
                # Sample the objective function
                x = np.zeros(n)
                x[i] = 1
                if i != j:
                    x[j] = 1

                value = objective(x)
                Q[i, j] = value
                if i != j:
                    Q[j, i] = value

        # Add penalty terms for constraints
        if constraints:
            penalty_weight = 10.0
            for constraint in constraints:
                for i in range(n):
                    x = np.zeros(n)
                    x[i] = 1
                    penalty = constraint(x)
                    Q[i, i] += penalty_weight * penalty

        return Q

    def solve_knapsack_annealing(
        self, weights: List[float], values: List[float], capacity: float
    ) -> Dict[str, Any]:
        """
        Solve knapsack problem using quantum annealing.

        This is relevant for breaking knapsack-based cryptosystems like
        Merkle-Hellman or subset sum cryptography.

        Args:
            weights: Item weights
            values: Item values
            capacity: Knapsack capacity

        Returns:
            Solution dictionary
        """
        print(f"[*] Solving knapsack problem with quantum annealing")
        print(f"[*] Items: {len(weights)}, Capacity: {capacity}")

        n = len(weights)

        # Define objective function: maximize value
        def objective(x: np.ndarray) -> float:
            """Objective function for knapsack problem."""
            return -np.dot(x, values)  # Negative because we minimize

        # Define constraint: total weight <= capacity
        def weight_constraint(x: np.ndarray) -> float:
            """Weight constraint for knapsack problem."""
            total_weight = np.dot(x, weights)
            violation = max(0, total_weight - capacity)
            return violation**2

        # Create QUBO matrix
        Q = self.create_qubo_matrix(objective, [weight_constraint])

        # Solve using quantum annealing
        if self.use_dwave:
            solution = self._solve_dwave(Q)
        else:
            solution = self._solve_simulated_annealing(Q)

        # Extract results
        selected_items = [i for i, x in enumerate(solution) if x == 1]
        total_weight = sum(weights[i] for i in selected_items)
        total_value = sum(values[i] for i in selected_items)

        result = {
            "solution": solution,
            "selected_items": selected_items,
            "total_weight": total_weight,
            "total_value": total_value,
            "capacity": capacity,
            "feasible": total_weight <= capacity,
            "n_items": n,
        }

        if result["feasible"]:
            print(f"[+] Found feasible solution:")
            print(f"    Selected: {len(selected_items)}/{n} items")
            print(f"    Weight: {total_weight}/{capacity}")
            print(f"    Value: {total_value}")
        else:
            print(f"[-] Solution violates capacity constraint")

        return result

    def solve_subset_sum_annealing(
        self, numbers: List[int], target: int
    ) -> Dict[str, Any]:
        """
        Solve subset sum problem using quantum annealing.

        Subset sum is NP-complete and used in various cryptographic schemes.
        Quantum annealing can find solutions more efficiently.

        Args:
            numbers: List of integers
            target: Target sum

        Returns:
            Solution dictionary
        """
        print(f"[*] Solving subset sum problem with quantum annealing")
        print(f"[*] Numbers: {len(numbers)}, Target: {target}")

        n = len(numbers)

        # Define objective: minimize |sum(selected) - target|^2
        def objective(x: np.ndarray) -> float:
            """Objective function for subset sum problem."""
            current_sum = np.dot(x, numbers)
            return (current_sum - target) ** 2

        # Create QUBO matrix
        Q = self.create_qubo_matrix(objective)

        # Solve
        if self.use_dwave:
            solution = self._solve_dwave(Q)
        else:
            solution = self._solve_simulated_annealing(Q)

        # Extract results
        selected_indices = [i for i, x in enumerate(solution) if x == 1]
        selected_numbers = [numbers[i] for i in selected_indices]
        achieved_sum = sum(selected_numbers)

        result = {
            "solution": solution,
            "selected_indices": selected_indices,
            "selected_numbers": selected_numbers,
            "target": target,
            "achieved_sum": achieved_sum,
            "error": abs(achieved_sum - target),
            "success": achieved_sum == target,
        }

        if result["success"]:
            print(f"[+] Found exact solution: {selected_numbers}")
            print(f"    Sum: {achieved_sum} = {target}")
        else:
            print(f"[-] Best solution: {selected_numbers}")
            print(f"    Sum: {achieved_sum}, Error: {result['error']}")

        return result

    def attack_lattice_crypto(
        self, lattice_basis: np.ndarray, target_vector: np.ndarray
    ) -> Dict[str, Any]:
        """
        Use quantum annealing for lattice-based crypto attacks.

        Find the closest lattice vector to a target (CVP problem).

        Args:
            lattice_basis: Lattice basis vectors
            target_vector: Target vector

        Returns:
            Attack result
        """
        print(f"[*] Attacking lattice-based cryptography")
        print(f"[*] Lattice dimension: {lattice_basis.shape}")

        # This is a simplified version
        # Real lattice attacks would use more sophisticated techniques

        n = len(target_vector)

        # Define objective: minimize ||Bc - t||^2 where B is basis, c is coefficients
        def objective(c: np.ndarray) -> float:
            """Objective function for lattice closest vector problem."""
            lattice_point = lattice_basis @ c
            distance = np.linalg.norm(lattice_point - target_vector)
            return distance**2

        # For binary optimization, we need to discretize the coefficient space
        # This is a simplified demonstration

        result = {
            "lattice_basis": lattice_basis.tolist(),
            "target_vector": target_vector.tolist(),
            "success": False,
            "note": "Lattice attacks require advanced techniques beyond basic annealing",
        }

        print(
            f"[*] Note: Full lattice attack implementation requires specialized algorithms"
        )

        return result

    def _solve_dwave(self, Q: np.ndarray) -> List[int]:
        """
        Solve QUBO using D-Wave quantum annealer.

        Args:
            Q: QUBO matrix

        Returns:
            Binary solution vector
        """
        if not DWAVE_AVAILABLE:
            print("[!] D-Wave not available, using simulated annealing")
            return self._solve_simulated_annealing(Q)

        print("[*] Submitting to D-Wave quantum annealer...")

        try:
            # Convert to BQM (Binary Quadratic Model)
            bqm = dimod.BinaryQuadraticModel.from_numpy_matrix(Q)

            # Use D-Wave sampler
            sampler = EmbeddingComposite(DWaveSampler())
            sampleset = sampler.sample(bqm, num_reads=100)

            # Get best solution
            best_sample = sampleset.first.sample
            solution = [best_sample[i] for i in range(len(Q))]

            print(f"[+] D-Wave annealing complete")
            return solution

        except Exception as e:
            print(f"[!] D-Wave execution failed: {e}")
            print("[*] Falling back to simulated annealing")
            return self._solve_simulated_annealing(Q)

    def _solve_simulated_annealing(self, Q: np.ndarray) -> List[int]:
        """
        Solve QUBO using classical simulated annealing.

        Args:
            Q: QUBO matrix

        Returns:
            Binary solution vector
        """
        n = len(Q)

        # Initialize random solution
        x = np.random.randint(0, 2, n)

        # Simulated annealing parameters
        T_initial = 10.0
        T_final = 0.1
        cooling_rate = 0.95
        steps_per_temp = 100

        def energy(solution: np.ndarray) -> float:
            """Calculate energy of a solution state."""
            return solution @ Q @ solution

        current_energy = energy(x)
        best_x = x.copy()
        best_energy = current_energy

        T = T_initial
        while T > T_final:
            for _ in range(steps_per_temp):
                # Propose flip
                i = np.random.randint(0, n)
                x[i] = 1 - x[i]

                new_energy = energy(x)
                delta_E = new_energy - current_energy

                # Accept or reject
                if delta_E < 0 or np.random.random() < np.exp(-delta_E / T):
                    current_energy = new_energy
                    if current_energy < best_energy:
                        best_x = x.copy()
                        best_energy = current_energy
                else:
                    # Reject - flip back
                    x[i] = 1 - x[i]

            T *= cooling_rate

        return best_x.tolist()


def demonstrate_quantum_annealing() -> None:
    """Demonstrate quantum annealing attacks."""
    print("=" * 60)
    print("Quantum Annealing Cryptographic Attacks")
    print("=" * 60)

    qa = QuantumAnnealingAttack(problem_size=8)

    # Example 1: Knapsack attack
    print("\n[*] Example 1: Knapsack-based cryptosystem attack")
    weights = [2, 3, 4, 5, 6, 7, 8, 9]
    values = [3, 4, 5, 6, 7, 8, 9, 10]
    capacity = 20

    result = qa.solve_knapsack_annealing(weights, values, capacity)

    # Example 2: Subset sum attack
    print("\n[*] Example 2: Subset sum problem attack")
    numbers = [3, 7, 12, 19, 23, 31, 43, 57]
    target = 50

    result = qa.solve_subset_sum_annealing(numbers, target)

    # Example 3: Lattice attack (simplified)
    print("\n[*] Example 3: Lattice-based crypto attack")
    lattice_basis = np.array([[2, 1], [1, 2]])
    target_vector = np.array([5, 5])

    result = qa.attack_lattice_crypto(lattice_basis, target_vector)

    print("\n" + "=" * 60)
    print("[+] Demonstration complete")
    print("[*] Note: Quantum annealing provides speedup for NP-hard problems")


if __name__ == "__main__":
    demonstrate_quantum_annealing()
