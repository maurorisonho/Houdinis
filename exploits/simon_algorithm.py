"""
Houdinis Framework - Simon's Algorithm Implementation
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
License: MIT

Simon's algorithm solves the period-finding problem exponentially faster
than classical algorithms. It can be used to break certain symmetric-key
cryptographic constructions.

Use Case: Finding hidden periodicities in cryptographic functions.
"""

import sys
from pathlib import Path
import random
from typing import List, Dict, Any, Optional, Tuple

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit.circuit.library import QFT
    from qiskit_aer import Aer
    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False
    print("[!] Qiskit not available. Using classical simulation.")

from quantum.backend import QuantumBackendBase
from quantum.simulator import QuantumSimulator


class SimonAlgorithm:
    """
    Implementation of Simon's algorithm for finding hidden periodicity.
    
    Simon's problem: Given a function f: {0,1}^n -> {0,1}^n that is either
    one-to-one or two-to-one with a hidden period s, find s.
    
    If f is two-to-one: f(x) = f(y) if and only if x ⊕ y = s
    """
    
    def __init__(self, n_bits: int = 3, backend=None):
        """
        Initialize Simon's algorithm.
        
        Args:
            n_bits: Number of input bits (determines problem size)
            backend: Quantum backend to use (optional)
        """
        self.n_bits = n_bits
        self.backend = backend
        self.simulator = QuantumSimulator(num_qubits=2 * n_bits)
        
    def create_oracle(self, secret_string: str) -> QuantumCircuit:
        """
        Create the oracle circuit for Simon's algorithm.
        
        The oracle implements a function f(x) where f(x) = f(x ⊕ s)
        for a secret string s.
        
        Args:
            secret_string: The hidden period (binary string)
            
        Returns:
            QuantumCircuit implementing the oracle
        """
        if not QISKIT_AVAILABLE:
            raise RuntimeError("Qiskit is required for oracle creation")
        
        n = len(secret_string)
        oracle = QuantumCircuit(2 * n, name='Simon Oracle')
        
        # Copy input to output (first part of oracle)
        for i in range(n):
            oracle.cx(i, n + i)
        
        # Apply transformations based on secret string
        for i in range(n):
            if secret_string[i] == '1':
                # Apply controlled operations
                for j in range(n):
                    if i != j:
                        oracle.cx(i, n + j)
        
        return oracle
    
    def create_simon_circuit(self, secret_string: str) -> QuantumCircuit:
        """
        Create the complete Simon's algorithm circuit.
        
        Args:
            secret_string: The hidden period to find
            
        Returns:
            Complete quantum circuit
        """
        if not QISKIT_AVAILABLE:
            raise RuntimeError("Qiskit is required for circuit creation")
        
        n = len(secret_string)
        
        # Create quantum and classical registers
        q_input = QuantumRegister(n, 'input')
        q_output = QuantumRegister(n, 'output')
        c = ClassicalRegister(n, 'c')
        
        circuit = QuantumCircuit(q_input, q_output, c)
        
        # Initialize: Apply Hadamard to input qubits
        circuit.h(q_input)
        
        # Apply the oracle
        oracle = self.create_oracle(secret_string)
        circuit.append(oracle, range(2 * n))
        
        # Apply Hadamard to input qubits again
        circuit.h(q_input)
        
        # Measure input qubits
        circuit.measure(q_input, c)
        
        return circuit
    
    def solve_linear_system(self, measurements: List[str], n: int) -> Optional[str]:
        """
        Solve the system of linear equations to find the secret string.
        
        From Simon's algorithm, we get measurements y where y · s = 0 (mod 2).
        We need to solve this system to find s.
        
        Args:
            measurements: List of measurement results (binary strings)
            n: Length of the secret string
            
        Returns:
            The secret string s, or None if not found
        """
        # Convert measurements to matrix
        matrix = []
        for measurement in measurements:
            if measurement != '0' * n:  # Skip trivial measurements
                row = [int(bit) for bit in measurement]
                matrix.append(row)
        
        if len(matrix) < n - 1:
            return None
        
        # Use Gaussian elimination (mod 2) to find null space
        # This is a simplified version for demonstration
        result = self._gaussian_elimination_gf2(matrix, n)
        
        return result
    
    def _gaussian_elimination_gf2(self, matrix: List[List[int]], n: int) -> str:
        """
        Perform Gaussian elimination in GF(2) to find null space.
        
        Args:
            matrix: System of equations (mod 2)
            n: Size of the system
            
        Returns:
            Solution vector as binary string
        """
        # Create augmented matrix
        rows = len(matrix)
        
        # Forward elimination
        for col in range(min(rows, n)):
            # Find pivot
            pivot_row = None
            for row in range(col, rows):
                if matrix[row][col] == 1:
                    pivot_row = row
                    break
            
            if pivot_row is None:
                continue
            
            # Swap rows
            if pivot_row != col:
                matrix[col], matrix[pivot_row] = matrix[pivot_row], matrix[col]
            
            # Eliminate
            for row in range(rows):
                if row != col and matrix[row][col] == 1:
                    for k in range(n):
                        matrix[row][k] ^= matrix[col][k]
        
        # Back substitution to find solution
        # For Simon's algorithm, we need to find a vector in the null space
        solution = ['0'] * n
        
        # Find free variable (one that's not determined by the system)
        for i in range(n):
            is_free = True
            for row in matrix:
                if row[i] == 1 and sum(row[i+1:]) == 0:
                    is_free = False
                    break
            
            if is_free:
                solution[i] = '1'
                break
        
        # Compute dependent variables
        for row_idx in range(len(matrix) - 1, -1, -1):
            row = matrix[row_idx]
            # Find leading 1
            leading = -1
            for i, val in enumerate(row):
                if val == 1:
                    leading = i
                    break
            
            if leading != -1:
                # Compute this variable
                val = 0
                for i in range(leading + 1, n):
                    val ^= (row[i] & int(solution[i]))
                solution[leading] = str(val)
        
        return ''.join(solution)
    
    def find_hidden_period(self, secret_string: str, num_shots: int = 100) -> Dict[str, Any]:
        """
        Run Simon's algorithm to find the hidden period.
        
        Args:
            secret_string: The actual hidden period (for testing)
            num_shots: Number of measurements to perform
            
        Returns:
            Results dictionary containing the found period
        """
        n = len(secret_string)
        
        print(f"[*] Running Simon's algorithm for {n}-bit problem")
        print(f"[*] Secret string: {secret_string}")
        
        if QISKIT_AVAILABLE and self.backend:
            # Use quantum backend
            circuit = self.create_simon_circuit(secret_string)
            
            try:
                from qiskit import transpile
                transpiled = transpile(circuit, self.backend)
                job = self.backend.run(transpiled, shots=num_shots)
                result = job.result()
                counts = result.get_counts()
                
                # Extract measurements
                measurements = list(counts.keys())
                
            except Exception as e:
                print(f"[!] Backend execution failed: {e}")
                print("[*] Falling back to simulator")
                measurements = self._simulate_measurements(n, secret_string, num_shots)
        else:
            # Use classical simulation
            measurements = self._simulate_measurements(n, secret_string, num_shots)
        
        # Solve the system of linear equations
        found_period = self.solve_linear_system(measurements, n)
        
        result = {
            'secret_string': secret_string,
            'found_period': found_period,
            'measurements': measurements[:10],  # First 10 measurements
            'success': found_period == secret_string,
            'n_bits': n
        }
        
        if found_period == secret_string:
            print(f"[+] Success! Found period: {found_period}")
        else:
            print(f"[-] Found period {found_period} does not match secret {secret_string}")
        
        return result
    
    def _simulate_measurements(self, n: int, secret: str, num_shots: int) -> List[str]:
        """
        Simulate quantum measurements for Simon's algorithm.
        
        Args:
            n: Number of bits
            secret: Secret string
            num_shots: Number of measurements
            
        Returns:
            List of measurement results
        """
        measurements = []
        
        for _ in range(num_shots):
            # Generate random measurement orthogonal to secret
            # y · s = 0 (mod 2)
            measurement = self._generate_orthogonal_vector(secret)
            measurements.append(measurement)
        
        return measurements
    
    def _generate_orthogonal_vector(self, secret: str) -> str:
        """
        Generate a random vector orthogonal to the secret string (mod 2).
        
        Args:
            secret: Secret string
            
        Returns:
            Orthogonal vector as binary string
        """
        n = len(secret)
        
        # If secret is all zeros, return random string
        if secret == '0' * n:
            return ''.join(random.choice('01') for _ in range(n))
        
        # Generate random vector
        vector = [random.randint(0, 1) for _ in range(n)]
        
        # Compute dot product (mod 2)
        dot_product = sum(int(secret[i]) * vector[i] for i in range(n)) % 2
        
        # If not orthogonal, flip first non-zero bit
        if dot_product == 1:
            for i in range(n):
                if secret[i] == '1':
                    vector[i] ^= 1
                    break
        
        return ''.join(map(str, vector))


def demonstrate_simon():
    """Demonstrate Simon's algorithm with examples."""
    print("=" * 60)
    print("Simon's Algorithm Demonstration")
    print("=" * 60)
    
    # Example 1: 3-bit problem
    print("\n[*] Example 1: 3-bit problem")
    simon = SimonAlgorithm(n_bits=3)
    secret = "101"
    result = simon.find_hidden_period(secret, num_shots=50)
    
    print(f"    Secret: {result['secret_string']}")
    print(f"    Found:  {result['found_period']}")
    print(f"    Success: {result['success']}")
    
    # Example 2: 4-bit problem
    print("\n[*] Example 2: 4-bit problem")
    simon = SimonAlgorithm(n_bits=4)
    secret = "1010"
    result = simon.find_hidden_period(secret, num_shots=100)
    
    print(f"    Secret: {result['secret_string']}")
    print(f"    Found:  {result['found_period']}")
    print(f"    Success: {result['success']}")
    
    print("\n" + "=" * 60)
    print("[+] Demonstration complete")


if __name__ == "__main__":
    demonstrate_simon()
