#!/usr/bin/env python3
"""
Houdinis Framework - Exploit Runner
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
Developed by: Human Logic & Coding with AI Assistance (Claude Sonnet 4.5)
License: MIT

Command-line interface for running individual Houdinis modules
"""

import sys
import os

sys.path.append(os.path.dirname(os.path.abspath(__file__)))

import importlib.util
import argparse
from pathlib import Path


class ExploitRunner:
    """Runner for Houdinis exploit modules"""

    def __init__(self):
        self.available_exploits = {
            "rsa_shor": {
                "path": "exploits/rsa_shor.py",
                "description": "RSA factorization using Shor's algorithm",
                "usage": "rsa_shor <target_number> [backend_type]",
            },
            "dh_shor": {
                "path": "exploits/dh_shor.py",
                "description": "Diffie-Hellman discrete log attack",
                "usage": "dh_shor <generator> <public_key> <prime>",
            },
            "grover_bruteforce": {
                "path": "exploits/grover_bruteforce.py",
                "description": "Grover's algorithm brute force attack",
                "usage": "grover_bruteforce <target_hash> [hash_type] [max_length]",
            },
            "ecdsa_vuln_scanner": {
                "path": "exploits/ecdsa_vuln_scanner.py",
                "description": "ECDSA quantum vulnerability scanner",
                "usage": "ecdsa_vuln_scanner <target_host1> [target_host2] ... [--port PORT]",
            },
            "aes_assessment": {
                "path": "exploits/aes_assessment.py",
                "description": "AES quantum vulnerability assessment",
                "usage": "aes_assessment <comprehensive|single> [key_size] [mode]",
            },
            "tls_sndl": {
                "path": "exploits/tls_sndl.py",
                "description": "TLS Store Now Decrypt Later attack",
                "usage": "tls_sndl <target_host1> [target_host2] ... [--port PORT]",
            },
            "quantum_rng": {
                "path": "exploits/quantum_rng.py",
                "description": "Quantum Random Number Generator",
                "usage": "quantum_rng <bits|key|benchmark> [options]",
            },
            "ssh_quantum_attack": {
                "path": "exploits/ssh_quantum_attack.py",
                "description": "SSH quantum vulnerability assessment",
                "usage": "ssh_quantum_attack <target_host1> [target_host2] ... [--port PORT]",
            },
            "bitcoin_key_recovery": {
                "path": "exploits/bitcoin_key_recovery.py",
                "description": "Bitcoin quantum key recovery analysis",
                "usage": "bitcoin_key_recovery <address1> [address2] ... [--file addresses.txt]",
            },
            "pgp_quantum_crack": {
                "path": "exploits/pgp_quantum_crack.py",
                "description": "PGP/GPG quantum vulnerability analysis",
                "usage": "pgp_quantum_crack <key_file1> [key_file2] ... [--output report.txt]",
            },
            "ipsec_quantum_vuln": {
                "path": "exploits/ipsec_quantum_vuln.py",
                "description": "IPSec quantum vulnerability scanner",
                "usage": "ipsec_quantum_vuln <target1> [target2] ... [--config config.conf]",
            },
            "ike_quantum_attack": {
                "path": "exploits/ike_quantum_attack.py",
                "description": "IKE quantum attack and security assessment",
                "usage": "ike_quantum_attack <target1> [target2] ... [--ports 500 4500]",
            },
            "pq_migration_tools": {
                "path": "exploits/pq_migration_tools.py",
                "description": "Post-quantum migration assessment tools",
                "usage": "pq_migration_tools <directory> [--output report.txt] [--format json]",
            },
            "quantum_network_recon": {
                "path": "exploits/quantum_network_recon.py",
                "description": "Quantum-focused network reconnaissance",
                "usage": "quantum_network_recon <network1> [network2] ... [--output report.txt]",
            },
        }

    def list_exploits(self):
        """List all available exploits"""
        print(" Houdinis Framework - Available Exploits")
        print("=" * 60)

        for name, info in self.available_exploits.items():
            print(f"\n {name}")
            print(f"   Description: {info['description']}")
            print(f"   Usage: {info['usage']}")

        print(f"\n Run exploit: python run_exploit.py <exploit_name> [args...]")
        print(f" Example: python run_exploit.py rsa_shor 15")

    def run_exploit(self, exploit_name: str, args: list):
        """Run a specific exploit"""
        if exploit_name not in self.available_exploits:
            print(f" Unknown exploit: {exploit_name}")
            print(f"Available exploits: {', '.join(self.available_exploits.keys())}")
            return False

        exploit_info = self.available_exploits[exploit_name]
        exploit_path = exploit_info["path"]

        # Check if exploit file exists
        if not os.path.exists(exploit_path):
            print(f" Exploit file not found: {exploit_path}")
            return False

        print(f"[TARGET] Running exploit: {exploit_name}")
        print(f"[FILE] Description: {exploit_info['description']}")
        print(f"[DIRECTORY] Path: {exploit_path}")
        print("=" * 50)

        try:
            # Load and execute the exploit module
            spec = importlib.util.spec_from_file_location(exploit_name, exploit_path)
            module = importlib.util.module_from_spec(spec)

            # Set up sys.argv for the exploit
            original_argv = sys.argv
            sys.argv = [exploit_path] + args

            try:
                # Execute the module
                spec.loader.exec_module(module)
                return True
            finally:
                # Restore original sys.argv
                sys.argv = original_argv

        except SystemExit as e:
            # Handle normal exit from exploit
            return e.code == 0
        except Exception as e:
            print(f" Error running exploit: {e}")
            import traceback

            traceback.print_exc()
            return False

    def show_help(self, exploit_name: str = None):
        """Show help information"""
        if exploit_name:
            if exploit_name in self.available_exploits:
                info = self.available_exploits[exploit_name]
                print(f"[TARGET] {exploit_name}")
                print(f"Description: {info['description']}")
                print(f"Usage: {info['usage']}")
            else:
                print(f" Unknown exploit: {exploit_name}")
        else:
            print(" Houdinis Framework - Exploit Runner")
            print("=" * 50)
            print(
                "Usage: python run_exploit.py [options] <exploit_name> [exploit_args...]"
            )
            print()
            print("Options:")
            print("  -l, --list      List all available exploits")
            print("  -h, --help      Show this help message")
            print("  --help <name>   Show help for specific exploit")
            print()
            print("Examples:")
            print("  python run_exploit.py --list")
            print("  python run_exploit.py rsa_shor 15")
            print(
                "  python run_exploit.py grover_bruteforce 5d41402abc4b2a76b9719d911017c592 md5"
            )
            print("  python run_exploit.py ecdsa_vuln_scanner google.com github.com")


def main():
    """Main function"""
    runner = ExploitRunner()

    if len(sys.argv) < 2:
        runner.show_help()
        sys.exit(1)

    # Parse command line arguments
    if sys.argv[1] in ["-l", "--list"]:
        runner.list_exploits()
        sys.exit(0)
    elif sys.argv[1] in ["-h", "--help"]:
        if len(sys.argv) > 2:
            runner.show_help(sys.argv[2])
        else:
            runner.show_help()
        sys.exit(0)

    # Run exploit
    exploit_name = sys.argv[1]
    exploit_args = sys.argv[2:] if len(sys.argv) > 2 else []

    success = runner.run_exploit(exploit_name, exploit_args)
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
